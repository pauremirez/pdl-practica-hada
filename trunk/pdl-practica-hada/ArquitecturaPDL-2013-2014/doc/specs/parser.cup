package compiler.syntax;

//-----------------------------
// Declaracion de importaciones 
//-----------------------------
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

//-----------------------------------
// Declaracion del codigo de usuario
//-----------------------------------

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	// Cadenas 
	List cadenas = new ArrayList();
	
	// Etiquetas 
	List etiqueta = new ArrayList();
	
	// Desplazamiento con RA principal
	int despl=5;

	// Desplazamiento x ambito
	HashMap desplScope = new HashMap(); 

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
		Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

//------------------------------------
// Declaracion de terminales (Ejemplo)
//------------------------------------
terminal Token MAS;
terminal Token ARRAY;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FUNCTION;
terminal Token IF;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OF;
terminal Token OR;
terminal Token OUT;
terminal Token PROCEDURE;
terminal Token PUTLINE;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
terminal Token WHILE;
terminal Token COMILLASDOBLES;
terminal Token PARENTESISIZQ;
terminal Token PARENTESISDER;
terminal Token INICIOCOMENTARIO;
terminal Token SALTOLINEA;
terminal Token COMA;
terminal Token PUNTOYCOMA;
terminal Token DOSPUNTOS;
terminal Token MENOS;
terminal Token MENORQUE;
terminal Token MAYORQUE;
terminal Token IGUALQUE;
terminal Token DISTINTOQUE;
terminal Token AND;
terminal Token ASIGNACION;
terminal Token PUNTO;
terminal Token ID; //Identificador
terminal Token ENTERO;
terminal Token PUNTOPUNTO;
terminal Token CARACTERESCADENA;

//-----------------------------
// Declaracion de no terminales
//-----------------------------
// no modificar los propuestos

non terminal Axiom				axiom;
non terminal					program;
non terminal  					seccionTipos;
non terminal  					seccionVariables;
non terminal BloqueSentencias	seccionSubProgramas;
non terminal 					seccionConstantesSimbolicas;
non terminal  					declaracionConstanteSimbolica;
non terminal  					declaracionTipo;
non terminal  					declaracionVariable;
non terminal BloqueSentencias	declaracionSubPrograma;
non terminal BloqueSentencias	funcion;
non terminal BloqueSentencias	procedimiento;
non terminal ListaObjetos		parametros;
non terminal ListaObjetos		lista_argumentos;
non terminal ListaObjetos		lista_parametros;
non terminal ListaObjetos		decVariable; 
non terminal BloqueSentencias	listaSentencias;
non terminal BloqueSentencias	sentencia;
non terminal BloqueSentencias	sentenciaProcedimiento;
non terminal BloqueSentencias 	sentenciaPutLine;
non terminal BloqueSentencias	sentenciaWhile;
non terminal BloqueSentencias	sentenciaIf;
non terminal BloqueSentencias	sentenciaAsignacion;
non terminal BloqueSentencias	idTipos;
non terminal Expresion			expresion;
non terminal Token				tipoBooleano;
non terminal  					vacio;
non terminal BloqueSentencias	cuerpoFuncion;
non terminal BloqueSentencias	cabecera;
non terminal BloqueSentencias	cuerpo;
non terminal Expresion			sentenciaFuncion;
non terminal ListaObjetos 		lista_parametros_llamada;
non terminal					tipos;
non terminal ListaObjetos		parametro;
non terminal					modo;
non terminal BloqueSentencias	procedure;
non terminal Expresion 			vector;

//-----------------------------------------
// Declaracion de relaciones de precedencia
//-----------------------------------------
precedence left MAS, MENOS;
precedence nonassoc ASIGNACION;
precedence left MENORQUE, MAYORQUE, DISTINTOQUE, IGUALQUE;
precedence left AND, OR;
precedence left PARENTESISIZQ, PARENTESISDER, PUNTO;
precedence right ELSE; 

//------------------------------------
// Declaracion de reglas de produccion
//-------------------------------------

start with program;

program::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden anadir mas acciones semanticas
  		// Comentar estas lineas para el 1er cuatrimestre

         ScopeIF scope = scopeManager.getCurrentScope();
         Variable var = new Variable(scopeManager.getCurrentScope().getName(),scope); 
				
         desplScope.put(scopeManager.getCurrentScope().getName(), new Integer(despl));
         var.setTablaDespl(desplScope);
                              		
  		 IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
  		 cb.addQuadruple ("INICIO_PROGRAMA", var, new Value(despl));
  		 
  		 List intermediateCode = ax.getIntermediateCode ();
		 
  		 cb.addQuadruples (intermediateCode);
         cb.addQuadruple ("FIN_PROGRAMA",null);
         
         // ponemos todas las cadena al final del programa
         int i=1;
         cb.addQuadruple ("CADENA", "cadena0","\"\\n\"", "");
         for (Iterator it = cadenas.iterator(); it.hasNext();i++){
              String nombre="cadena"+i;
              cb.addQuadruple ("CADENA", nombre,it.next(), "");
         }

  		 finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		 finalCodeFactory.create(cb.create());

         List code = cb.create();
		 ax.setIntermediateCode(code);
		 
		 semanticErrorManager.semanticDebug(ax.getIntermediateCode());
  		
  		 syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

// ----------------------
// Inicio programa
// ----------------------
axiom::= procedure PARENTESISIZQ PARENTESISDER IS cabecera:bloque1 cuerpo:bloque {:
                  
                            // Creamos el codigo CI de todo el arbol
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());                               

							cb.addQuadruples(bloque1.getIntermediateCode());
                            cb.addQuadruples(bloque.getIntermediateCode());

                            List code = cb.create();
                            Axiom ax = new Axiom();
                            ax.setIntermediateCode(code);
                            			
                            semanticErrorManager.semanticDebug(ax.getIntermediateCode());
                            RESULT=ax;
				
			:} | procedure PARENTESISIZQ PARENTESISDER IS cuerpo:bloque {:
                            // Creamos el codigo CI de todo el arbol
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());   

                            cb.addQuadruples(bloque.getIntermediateCode());

                            List code = cb.create();
                            Axiom ax = new Axiom();
                            ax.setIntermediateCode(code);
                            			
                            semanticErrorManager.semanticDebug(ax.getIntermediateCode());
                            RESULT=ax;
				
			:} ;
axiom::= procedure error PARENTESISIZQ PARENTESISDER IS cabecera cuerpo {:syntaxErrorManager.syntaxFatalError("001. No se ha especificado nombre del progama");:} |
		ID error PARENTESISIZQ PARENTESISDER IS cabecera cuerpo {:syntaxErrorManager.syntaxFatalError("003. Palabra PROCEDURE no definida");:};

procedure::=PROCEDURE ID:id 
{:
	String name=id.getLexema();
	scopeManager.openScope(name);
	
	//Insertar todos los TypesSimple en la TT
	ScopeIF scope = scopeManager.getCurrentScope();
	TypeTableIF tableTypes =scope.getTypeTable();
	TypeInteger typeInteger = new TypeInteger(scope);
	TypeBoolean typeBoolean = new TypeBoolean(scope);
	TypeArray typeArray = new TypeArray(scope);
	tableTypes.addType(typeInteger);
	tableTypes.addType(typeBoolean);
	tableTypes.addType(typeArray);
:};
procedure::= PROCEDURE error  {:syntaxErrorManager.syntaxFatalError("002. Error en el nombre del programa");:};

cabecera::= seccionConstantesSimbolicas seccionTipos seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionTipos seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionTipos seccionVariables {:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionConstantesSimbolicas seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionVariables {:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionConstantesSimbolicas{:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionTipos seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionTipos seccionVariables {:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionTipos seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionTipos {:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :}|
			seccionVariables {:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :};

seccionConstantesSimbolicas::= declaracionConstanteSimbolica | seccionConstantesSimbolicas declaracionConstanteSimbolica ;
seccionTipos::= declaracionTipo | seccionTipos declaracionTipo;
seccionVariables::= declaracionVariable {:
                                desplScope.put(scopeManager.getCurrentScope().getName(),despl); 
                            :}| seccionVariables declaracionVariable {:
                                desplScope.put(scopeManager.getCurrentScope().getName(),despl); 
                            :};
seccionSubProgramas::= declaracionSubPrograma:bloque {:
                                RESULT=bloque; :}  | 
                       declaracionSubPrograma:bloque1 seccionSubProgramas:bloque2 {:
                                BloqueSentencias bloque = new BloqueSentencias();
                                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
								List code1 = bloque1.getIntermediateCode();
								List code2 = bloque2.getIntermediateCode();
								cb.addQuadruples (code1);
								cb.addQuadruples (code2);
								List code=cb.create ();
								bloque.setIntermediateCode (code); 
                                RESULT=bloque;
:};

// --------------------
// Seccion Constantes
// -------------------
declaracionConstanteSimbolica::= ID:id DOSPUNTOS CONSTANT ASIGNACION ENTERO:value PUNTOYCOMA
{:
	String name=id.getLexema();
	SymbolTableIF sTable=scopeManager.getCurrentScope().getSymbolTable();
	
	//si la cte está declarada en el ambito --> error: ya ha sido declarada
	//si no --> declararla	
	if(sTable.containsSymbol(name)){
		semanticErrorManager.semanticFatalError("La CONSTANTE "+name+" en la linea "+id.getLine()+" ya ha sido declarada");
	}else{
		SymbolConstant sc= new SymbolConstant (scopeManager.getCurrentScope(),name,scopeManager.searchType("INTEGER"),despl);
		sTable.addSymbol(name,sc);
		sc.setValue(Integer.parseInt(value.getLexema()));
	}
:};
declaracionConstanteSimbolica::= ID:id DOSPUNTOS CONSTANT ASIGNACION tipoBooleano:valor PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si la cte está declarada en el ambito --> error: ya ha sido declarada
	//si no --> declararla	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("La CONSTANTE "+name+" en la linea "+id.getLine()+" ya ha sido declarada");
	}else{
		SymbolTableIF tableSymbol=scope.getSymbolTable();
		SymbolConstant constantSymbol=new SymbolConstant(scope,name, scopeManager.searchType("BOOLEAN"));
		if (valor.getLexema().equalsIgnoreCase("true")) 
			constantSymbol.setValue(1);
		else 
			constantSymbol.setValue(0);
		tableSymbol.addSymbol(name,constantSymbol);
	}
:};

// --------------------
// Seccion TIPOS
// --------------------
declaracionTipo::= TYPE ID:id IS ARRAY PARENTESISIZQ ENTERO:value1 PUNTOPUNTO ENTERO:value2 PARENTESISDER OF INTEGER PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si el tipo está declarado en el ambito --> error: ya ha sido declarado
	//si no --> declararlo	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("El TIPO "+name+" en la linea "+id.getLine()+" y columna "+id.getColumn()+" ya ha sido declarado");
	}else{
		TypeTableIF tableType=scope.getTypeTable();
		TypeArray typeArray =new TypeArray (scope, name);
		typeArray.setValIni (Integer.parseInt(value1.getLexema()));
		typeArray.setValFin (Integer.parseInt(value2.getLexema()));
		typeArray.setTipo (scopeManager.searchType("INTEGER"));
		tableType.addType(name,typeArray);
	}
:};
declaracionTipo::= TYPE ID:id IS ARRAY PARENTESISIZQ ENTERO:value1 PUNTOPUNTO ENTERO:value2 PARENTESISDER OF BOOLEAN PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si el tipo está declarado en el ambito --> error: ya ha sido declarado
	//si no --> declararlo	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("El TIPO "+name+" en la linea "+id.getLine()+" y columna "+id.getColumn()+" ya ha sido declarado");
	}else{
		TypeTableIF tableType=scope.getTypeTable();
		TypeArray typeArray =new TypeArray (scope, name);
		typeArray.setValIni (Integer.parseInt(value1.getLexema()));
		typeArray.setValFin (Integer.parseInt(value2.getLexema()));
		typeArray.setTipo (scopeManager.searchType("BOOLEAN"));
		tableType.addType(name,typeArray);
	}
:};
declaracionTipo::= TYPE ID:id IS ARRAY PARENTESISIZQ ENTERO:value1 PUNTOPUNTO ENTERO:value2 PARENTESISDER OF ID:typeId PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si el tipo está declarado en el ambito --> error: ya ha sido declarado
	//si no --> declararlo	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("El TIPO "+name+" en la linea "+id.getLine()+" y columna "+id.getColumn()+" ya ha sido declarado");
	}else{
		TypeTableIF tableType=scope.getTypeTable();
		TypeArray typeArray =new TypeArray (scope, name);
		typeArray.setValIni (Integer.parseInt(value1.getLexema()));
		typeArray.setValFin (Integer.parseInt(value2.getLexema()));
		typeArray.setTipo (scopeManager.searchType(typeId.getLexema()));
		tableType.addType(name,typeArray);
		TypeIF typeVar=scopeManager.searchType(typeId.getLexema());
		
	}
:};

// --------------------
// Seccion VARIABLES
// --------------------

declaracionVariable::= decVariable:list INTEGER PUNTOYCOMA
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF tableSymbol=scope.getSymbolTable();

	//Añadir el tipo de variable a la lista
	ListaObjetos var=new ListaObjetos(list);
	for(int i=var.size()-1; i>=0;i--){
		Var v=(Var)var.get(i);
		//Comprobar que no esté definido el mismo ámbito
		if(!scope.getSymbolTable().containsSymbol(v.getName())){
			SymbolVariable symbolVariable=new SymbolVariable(scope, v.getName(), scopeManager.searchType("INTEGER"),despl);
			tableSymbol.addSymbol(v.getName(),symbolVariable);
			 despl++;
		}else{
			semanticErrorManager.semanticFatalError("La variable "+v.getName()+" en la linea "+v.getLine()+" y columna "+v.getColumn()+" ya ha sido declarada");
		}
	}
:};
declaracionVariable::= decVariable:list BOOLEAN PUNTOYCOMA
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF tableSymbol=scope.getSymbolTable();
	
	//Añadir el tipo de variable a la lista
	ListaObjetos var=new ListaObjetos(list);
	for(int i=var.size()-1; i>=0;i--){
		Var v=(Var)var.get(i);
		//Comprobar que no esté definido el mismo ámbito
		if(!scope.getSymbolTable().containsSymbol(v.getName())){
			SymbolVariable symbolVariable=new SymbolVariable(scope, v.getName(), scopeManager.searchType("BOOLEAN"),despl);
			tableSymbol.addSymbol(v.getName(),symbolVariable);
			despl++;
		}else{
			semanticErrorManager.semanticFatalError("La variable "+v.getName()+" en la linea "+v.getLine()+" y columna "+v.getColumn()+" ya ha sido declarada");
		}
	}
:};
declaracionVariable::= decVariable:list ID:type PUNTOYCOMA
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF tableSymbol=scope.getSymbolTable();
	TypeTableIF tableType=scope.getTypeTable();

	//Añadir el tipo de variable a la lista
	ListaObjetos var=new ListaObjetos(list);
	
	semanticErrorManager.semanticInfo("Lista variables: "+var.size());
	
	for(int i=var.size()-1; i>=0;i--){
		Var v=(Var)var.get(i);
		//Comprobar que no esté definido el mismo ámbito
		if(!scope.getSymbolTable().containsSymbol(v.getName())){
			SymbolVariable symbolVariable=new SymbolVariable(scope, v.getName(),scopeManager.searchType(type.getLexema()),despl);
			tableSymbol.addSymbol(v.getName(),symbolVariable);
			if(tableType.getType(type.getLexema()) instanceof TypeArray){
				TypeArray typeArray = (TypeArray) symbolVariable.getType();
				despl=despl+typeArray.getSize();
			}
		}else{
			semanticErrorManager.semanticFatalError("La variable "+v.getName()+" en la linea "+v.getLine()+" y columna "+v.getColumn()+" ya ha sido declarada");
		}
	}
	if(!scopeManager.containsType(type.getLexema())){
		semanticErrorManager.semanticFatalError("La variable "+type.getLexema()+" en la linea "+type.getLine()+" y columna "+type.getColumn()+" no ha sido declarada");
	}else{
		TypeIF typeIf=scopeManager.searchType(type.getLexema());
		if( !(typeIf instanceof TypeArray)){
			semanticErrorManager.semanticFatalError("La variable "+type.getLexema()+" en la linea "+type.getLine()+" y columna "+type.getColumn()+" no es del tipo RECORD/ARRAY");
		}
	}	
:};
// --------------------
// Seccion SUBPROGRAMAS
// --------------------
declaracionSubPrograma::= procedimiento:bloque {: RESULT=bloque; :}| funcion:bloque {: RESULT=bloque; :};

// ------------------------                     
// Definicion de FUNCION 
// ------------------------  
funcion::= FUNCTION ID:idFunc PARENTESISIZQ lista_parametros:listaArg PARENTESISDER RETURN tipos:tp IS 
{:
			//semanticErrorManager.semanticInfo("FUNCION: "+idFunc.getLexema()+" en la linea: "+idFunc.getLine());
 				// la funcion ha sido declarada
            if (scopeManager.containsSymbol(idFunc.getLexema())) {
				semanticErrorManager.semanticFatalError("La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" ya ha sido declarada");
            }else{ 
                                
				// Crear FUNCION en ambito
				ScopeIF scope = scopeManager.getCurrentScope();
                TypeTableIF tablaTipos = scope.getTypeTable();
	  			SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
                // a�adir funcion a TT
                TypeFunction tipoFuncion = new TypeFunction(scope, idFunc.getLexema());
				tablaTipos.addType(idFunc.getLexema(), tipoFuncion);
							
				// a�adir funcion a TS
                SymbolFunction simboloFunc = new SymbolFunction(scope,idFunc.getLexema(),tablaTipos.getType(idFunc.getLexema()));
				tablaSimbolos.addSymbol(idFunc.getLexema(), simboloFunc);
							
				// NUEVO ambito para funcion y tabla TS y TT
				scopeManager.openScope(idFunc.getLexema());             
														
				tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

                // Grabo tipo retorno
				tipoFuncion.setTipoRetorno(scopeManager.searchType(tp.toString()));

				// Grabo parametros funcion
                // ListaObjetos parametros = new ListaObjetos(listaArg) 
				ArrayList parametros = new ArrayList(Utilidades.ordenaParametros(listaArg));
                                
        			for (int i=0; i<parametros.size(); i++){
                                    Parametro p = (Parametro) parametros.get(i);
                                    SymbolVariable simboloVar = new SymbolVariable (scopeManager.getCurrentScope(), p.getNombre(), p.getTipo(),despl);
                                    despl++;
                                    // Creo lista ordenada de parametros en el PROCEDIMIENTO.
                                    tipoFuncion.setTypeParametro(p.getColumna(),p.getTipo()); 
                                    // Fijar paso parametros Ref/Valor en Symbolvar
                                    simboloVar.setReferencia(p.getReferencia());
                                    tablaSimbolos.addSymbol(p.getNombre(),simboloVar);                                  	
                                    tipoFuncion.setParametro(simboloVar);
                                } 
       
                // Grabo tipo retorno
                tipoFuncion.setTipoRetorno(scopeManager.searchType(tp.toString()));
                tipoFuncion.setHayRetorno(true);
                LabelFactoryIF lf = CompilerContext.getLabelFactory();
                LabelIF labelInicio = lf.create();
                tipoFuncion.setEtiqSub(labelInicio);
                LabelIF labelFin = lf.create();
                tipoFuncion.setEtiqSubFin(labelFin);                   
            }
:} 
cabecera:bloque1 cuerpoFuncion:bloque2 {:
                                BloqueSentencias bloque = new BloqueSentencias();
				                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
								List code1 = bloque1.getIntermediateCode();
								List code2 = bloque2.getIntermediateCode();
				                ScopeIF scope = scopeManager.getCurrentScope();
				                TypeFunction tipoFuncion = (TypeFunction) scopeManager.searchType(scope.getName());
				                cb.addQuadruple("INICIO_SUBPROG", tipoFuncion.getEtiqSub().getName());
								cb.addQuadruples (code1);
								cb.addQuadruples (code2);
				                cb.addQuadruple("FIN_SUBPROG", tipoFuncion.getEtiqSub().getName(), tipoFuncion.getEtiqSubFin().getName(),new Value(tipoFuncion.getScope().getLevel()));
								List code=cb.create();
								bloque.setIntermediateCode(code); 
				
				                // Cerramos Scope
				                desplScope.put(scope.getName(), new Integer(despl));
				                scopeManager.closeScope();
				
				                despl=((Integer)desplScope.get(scopeManager.getCurrentScope().getName())).intValue();
				                // Comprobar que hay return de la funcion
				
				                if  (! tipoFuncion.getHayRetorno())
				                  semanticErrorManager.semanticFatalError("La funcion "+tipoFuncion.getName()+" no tiene retorno"); 
				               
				                semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
				                RESULT=bloque;
              
:};
funcion::= FUNCTION ID:idFunc PARENTESISIZQ PARENTESISDER RETURN tipos:tp IS 
{:
			//semanticErrorManager.semanticInfo("FUNCION: "+idFunc.getLexema()+" en la linea: "+idFunc.getLine());
 			// la funcion ha sido declarada
            if (scopeManager.containsSymbol(idFunc.getLexema())) {
				semanticErrorManager.semanticFatalError("La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" ya ha sido declarada");
            }else{ 
                                
				// Crear FUNCION en ambito
				ScopeIF scope = scopeManager.getCurrentScope();
                TypeTableIF tablaTipos = scope.getTypeTable();
	  			SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
                // a�adir funcion a TT
                TypeFunction tipoFuncion = new TypeFunction(scope, idFunc.getLexema());
				tablaTipos.addType(idFunc.getLexema(), tipoFuncion);
							
				// a�adir funcion a TS
                SymbolFunction simboloFunc = new SymbolFunction(scope,idFunc.getLexema(),tablaTipos.getType(idFunc.getLexema()));
				tablaSimbolos.addSymbol(idFunc.getLexema(), simboloFunc);
							
				// NUEVO ambito para funcion y tabla TS y TT
				scopeManager.openScope(idFunc.getLexema()); 
                                
														
				tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

                // Grabo tipo retorno
                tipoFuncion.setTipoRetorno(scopeManager.searchType(tp.toString()));
                tipoFuncion.setHayRetorno(true);
                LabelFactoryIF lf = CompilerContext.getLabelFactory();
                LabelIF labelInicio = lf.create();
                tipoFuncion.setEtiqSub(labelInicio);
                LabelIF labelFin = lf.create();
                tipoFuncion.setEtiqSubFin(labelFin);      
            }
:} 
cabecera:bloque1 cuerpoFuncion:bloque2 {:
                                BloqueSentencias bloque = new BloqueSentencias();
				                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
								List code1 = bloque1.getIntermediateCode();
								List code2 = bloque2.getIntermediateCode();
				                ScopeIF scope = scopeManager.getCurrentScope();
				                TypeFunction tipoFuncion = (TypeFunction) scopeManager.searchType(scope.getName());
				                cb.addQuadruple("INICIO_SUBPROG", tipoFuncion.getEtiqSub().getName());
								cb.addQuadruples (code1);
								cb.addQuadruples (code2);
				                cb.addQuadruple("FIN_SUBPROG", tipoFuncion.getEtiqSub().getName(), tipoFuncion.getEtiqSubFin().getName(),new Value(tipoFuncion.getScope().getLevel()));
								List code=cb.create();
								bloque.setIntermediateCode(code); 
				
				                // Cerramos Scope
				                desplScope.put(scope.getName(), new Integer(despl));
				                scopeManager.closeScope();
				
				                despl=((Integer)desplScope.get(scopeManager.getCurrentScope().getName())).intValue();
				                // Comprobar que hay return de la funcion
				
				                if  (! tipoFuncion.getHayRetorno())
				                  semanticErrorManager.semanticFatalError("La funci�n "+tipoFuncion.getName()+" no tiene retorno"); 
				               
				                semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
				                RESULT=bloque;
              
:}; 
funcion::= FUNCTION ID:idFunc PARENTESISIZQ lista_parametros:listaArg PARENTESISDER RETURN tipos:tp IS
{:
			//semanticErrorManager.semanticInfo("FUNCION: "+idFunc.getLexema()+" en la linea: "+idFunc.getLine());
 				// la funcion ha sido declarada
            if (scopeManager.containsSymbol(idFunc.getLexema())) {
				semanticErrorManager.semanticFatalError("La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" ya ha sido declarada");
           }else{ 
                                
				// Crear FUNCION en ambito
				ScopeIF scope = scopeManager.getCurrentScope();
                TypeTableIF tablaTipos = scope.getTypeTable();
	  			SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
                // a�adir funcion a TT
                TypeFunction tipoFuncion = new TypeFunction(scope, idFunc.getLexema());
				tablaTipos.addType(idFunc.getLexema(), tipoFuncion);
							
				// a�adir funcion a TS
                SymbolFunction simboloFunc = new SymbolFunction(scope,idFunc.getLexema(),tablaTipos.getType(idFunc.getLexema()));
				tablaSimbolos.addSymbol(idFunc.getLexema(), simboloFunc);
							
				// NUEVO ambito para funcion y tabla TS y TT
				scopeManager.openScope(idFunc.getLexema()); 
                despl=5;                
														
				tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

                // Grabo tipo retorno
				tipoFuncion.setTipoRetorno(scopeManager.searchType(tp.toString()));

				// Grabo parametros funcion
				ArrayList parametros = new ArrayList(Utilidades.ordenaParametros(listaArg));
                                
       			for (int i=0; i<parametros.size(); i++){
                                    Parametro p = (Parametro) parametros.get(i);
                                    SymbolVariable simboloVar = new SymbolVariable (scopeManager.getCurrentScope(), p.getNombre(), p.getTipo(),despl);
                                    despl++;
                                    // Creo lista ordenada de parametros en el PROCEDIMIENTO.
                                    tipoFuncion.setTypeParametro(p.getColumna(),p.getTipo()); 
                                    // Fijar paso parametros Ref/Valor en Symbolvar
                                    simboloVar.setReferencia(p.getReferencia());
                                    tablaSimbolos.addSymbol(p.getNombre(),simboloVar);                                  	
                                    tipoFuncion.setParametro(simboloVar);
                                } 
       
                tipoFuncion.setTipoRetorno(scopeManager.searchType(tp.toString()));
                tipoFuncion.setHayRetorno(true);
                LabelFactoryIF lf = CompilerContext.getLabelFactory();
                LabelIF labelInicio = lf.create();
                tipoFuncion.setEtiqSub(labelInicio);
                LabelIF labelFin = lf.create();
                tipoFuncion.setEtiqSubFin(labelFin);        
              }
:} 
cuerpoFuncion:bloque2 {:
                BloqueSentencias bloque = new BloqueSentencias();
                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
				List code2 = bloque2.getIntermediateCode();
                ScopeIF scope = scopeManager.getCurrentScope();
                TypeFunction tipoFuncion = (TypeFunction) scopeManager.searchType(scope.getName());
                cb.addQuadruple("INICIO_SUBPROG", tipoFuncion.getEtiqSub().getName());
				
				cb.addQuadruples (code2);
                cb.addQuadruple("FIN_SUBPROG", tipoFuncion.getEtiqSub().getName(), tipoFuncion.getEtiqSubFin().getName(),new Value(tipoFuncion.getScope().getLevel()));
				List code=cb.create();
				bloque.setIntermediateCode(code); 

                // Cerramos Scope
                desplScope.put(scope.getName(), new Integer(despl));
                scopeManager.closeScope();

                despl=((Integer)desplScope.get(scopeManager.getCurrentScope().getName())).intValue();
                // Comprobar que hay return de la funcion

                if  (! tipoFuncion.getHayRetorno())
                  semanticErrorManager.semanticFatalError("La funcion "+tipoFuncion.getName()+" no tiene retorno"); 
                
                semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
                RESULT=bloque;
              
:};
funcion::= FUNCTION ID:idFunc PARENTESISIZQ PARENTESISDER RETURN tipos:tp IS 
{:
			//semanticErrorManager.semanticInfo("FUNCION: "+idFunc.getLexema()+" en la linea: "+idFunc.getLine());
               
 				// la funcion ha sido declarada
             if (scopeManager.containsSymbol(idFunc.getLexema())) {
				semanticErrorManager.semanticFatalError("La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" ya ha sido declarada");
             }else{ 
                                
				// Crear FUNCION en ambito
				ScopeIF scope = scopeManager.getCurrentScope();
                TypeTableIF tablaTipos = scope.getTypeTable();
	  			SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
                // a�adir funcion a TT
                TypeFunction tipoFuncion = new TypeFunction(scope, idFunc.getLexema());
				tablaTipos.addType(idFunc.getLexema(), tipoFuncion);
							
				// a�adir funcion a TS
                SymbolFunction simboloFunc = new SymbolFunction(scope,idFunc.getLexema(),tablaTipos.getType(idFunc.getLexema()));
				tablaSimbolos.addSymbol(idFunc.getLexema(), simboloFunc);
							
				// NUEVO ambito para funcion y tabla TS y TT
				scopeManager.openScope(idFunc.getLexema());                     
														
				tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

                // Grabo tipo retorno
				tipoFuncion.setTipoRetorno(scopeManager.searchType(tp.toString()));

				tipoFuncion.setTipoRetorno(scopeManager.searchType(tp.toString()));
                tipoFuncion.setHayRetorno(true);
                LabelFactoryIF lf = CompilerContext.getLabelFactory();
                LabelIF labelInicio = lf.create();
                tipoFuncion.setEtiqSub(labelInicio);
                LabelIF labelFin = lf.create();
                tipoFuncion.setEtiqSubFin(labelFin);                    
           }
:} 
cuerpoFuncion:bloque2 {:
                BloqueSentencias bloque = new BloqueSentencias();
                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
				List code2 = bloque2.getIntermediateCode();
                ScopeIF scope = scopeManager.getCurrentScope();
                TypeFunction tipoFuncion = (TypeFunction) scopeManager.searchType(scope.getName());
                cb.addQuadruple("INICIO_SUBPROG", tipoFuncion.getEtiqSub().getName());
				cb.addQuadruples (code2);
                cb.addQuadruple("FIN_SUBPROG", tipoFuncion.getEtiqSub().getName(), tipoFuncion.getEtiqSubFin().getName(),new Value(tipoFuncion.getScope().getLevel()));
				List code=cb.create();
				bloque.setIntermediateCode(code); 

                // Cerramos Scope
                desplScope.put(scope.getName(), new Integer(despl));
                scopeManager.closeScope();

                despl=((Integer)desplScope.get(scopeManager.getCurrentScope().getName())).intValue();
                // Comprobar que hay return de la funcion

                if  (! tipoFuncion.getHayRetorno())
                  semanticErrorManager.semanticFatalError("La funcion "+tipoFuncion.getName()+" no tiene retorno"); 
                
                 semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
                RESULT=bloque2;
              
:};  
funcion::= FUNCTION ID error RETURN tipos IS cuerpoFuncion {:syntaxErrorManager.syntaxFatalError("001. Faltan los DOS PARENTESIS");:};
			
cuerpoFuncion::= BEGIN listaSentencias:bloque PUNTOYCOMA END ID PUNTOYCOMA
{:
				 RESULT=bloque;
:}  |
				BEGIN PUNTOYCOMA END ID PUNTOYCOMA
{:
				BloqueSentencias bloque = new BloqueSentencias();
				 RESULT=bloque;
:} ;

// ----------------------------                     
// Definicion de PROCEDIMIENTO
// ----------------------------  
procedimiento::= PROCEDURE ID:idProc PARENTESISIZQ lista_parametros:listaArg PARENTESISDER IS
{:
				semanticErrorManager.semanticInfo("PROCEDIMIENTO: "+idProc.getLexema()+" en la linea: "+idProc.getLine());
 				// el procedimiento ha sido declarado
                if (scopeManager.containsSymbol(idProc.getLexema())) {
					semanticErrorManager.semanticFatalError("El procediiento "+idProc.getLexema()+" en la linea: "+idProc.getLine()+" ya ha sido declarado");
                }else{ 
                                
					// Crear FUNCION en ambito
					ScopeIF scope = scopeManager.getCurrentScope();
	                TypeTableIF tablaTipos = scope.getTypeTable();
		  			SymbolTableIF tablaSimbolos = scope.getSymbolTable();
								
	                // a�adir funcion a TT
	                TypeProcedure tipoProcedimiento = new TypeProcedure(scope, idProc.getLexema());
					tablaTipos.addType(idProc.getLexema(), tipoProcedimiento);
								
					// a�adir funcion a TS
	                SymbolProcedure simboloProc = new SymbolProcedure(scope,idProc.getLexema(),tablaTipos.getType(idProc.getLexema()));
					tablaSimbolos.addSymbol(idProc.getLexema(), simboloProc);
								
					// NUEVO ambito para funcion y tabla TS y TT
					scopeManager.openScope(idProc.getLexema()); 
	                                									
					tablaTipos = scopeManager.getCurrentScope().getTypeTable();
					tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

					// Grabo parametros funcion
					ArrayList parametros = new ArrayList(Utilidades.ordenaParametros(listaArg));
                                
        			for (int i=0; i<parametros.size(); i++){
                                    Parametro p = (Parametro) parametros.get(i);
                                    SymbolVariable simboloVar = new SymbolVariable (scopeManager.getCurrentScope(), p.getNombre(), p.getTipo(), despl);
                                    despl++;
                                    // Creo lista ordenada de parametros en el PROCEDIMIENTO.
                                    tipoProcedimiento.setTypeParametro(p.getColumna(),p.getTipo()); 
                                    // Fijar paso parametros Ref/Valor en Symbolvar
                                    simboloVar.setReferencia(p.getReferencia());
                                    tablaSimbolos.addSymbol(p.getNombre(),simboloVar);                                  	
                                    tipoProcedimiento.setParametro(simboloVar);
                                } 

                                LabelFactoryIF lf = CompilerContext.getLabelFactory();
                                LabelIF labelInicio = lf.create();
                                tipoProcedimiento.setEtiqSub(labelInicio);
                                LabelIF labelFin = lf.create();
                                tipoProcedimiento.setEtiqSubFin(labelFin);
                              }
:} 
cabecera:bloque1 cuerpo:bloque2 {:
                                ScopeIF scope = scopeManager.getCurrentScope();
                                BloqueSentencias bloque = new BloqueSentencias();
                                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
								List code1 = bloque1.getIntermediateCode();
								List code2 = bloque2.getIntermediateCode();
                                TypeProcedure tipoProc = (TypeProcedure) scopeManager.searchType(scope.getName());
                                cb.addQuadruple("INICIO_SUBPROG", tipoProc.getEtiqSub().getName());
                                cb.addQuadruples (code1);
								cb.addQuadruples (code2);
                                cb.addQuadruple("FIN_SUBPROG", tipoProc.getEtiqSub().getName(), tipoProc.getEtiqSubFin().getName(),new Value(tipoProc.getScope().getLevel()));
								List code=cb.create ();
								bloque.setIntermediateCode (code); 

                                // Cerramos Scope
                                desplScope.put(scope.getName(), new Integer(despl));
                                scopeManager.closeScope();

                                despl=((Integer)desplScope.get(scopeManager.getCurrentScope().getName())).intValue();
                                
                                semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
                                RESULT=bloque;
              
:};
procedimiento::= PROCEDURE ID:idProc PARENTESISIZQ lista_parametros:listaArg PARENTESISDER IS
{:
				semanticErrorManager.semanticInfo("PROCEDIMIENTO: "+idProc.getLexema()+" en la linea: "+idProc.getLine());
 				
 				// el procedimiento ha sido declarado
                            if (scopeManager.containsSymbol(idProc.getLexema())) {
				semanticErrorManager.semanticFatalError("El procediiento "+idProc.getLexema()+" en la linea: "+idProc.getLine()+" ya ha sido declarado");
                            }else{ 
                                
				// Crear FUNCION en ambito
				ScopeIF scope = scopeManager.getCurrentScope();
                TypeTableIF tablaTipos = scope.getTypeTable();
	  			SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
                // a�adir funcion a TT
                TypeProcedure tipoProcedimiento = new TypeProcedure(scope, idProc.getLexema());
				tablaTipos.addType(idProc.getLexema(), tipoProcedimiento);
							
				// a�adir funcion a TS
                 SymbolProcedure simboloProc = new SymbolProcedure(scope,idProc.getLexema(),tablaTipos.getType(idProc.getLexema()));
				tablaSimbolos.addSymbol(idProc.getLexema(), simboloProc);
							
				// NUEVO ambito para funcion y tabla TS y TT
				scopeManager.openScope(idProc.getLexema());                     
														
				tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();


				// Grabo parametros funcion
				ArrayList parametros = new ArrayList(Utilidades.ordenaParametros(listaArg));
                                
        			for (int i=0; i<parametros.size(); i++){
                                    Parametro p = (Parametro) parametros.get(i);
                                    SymbolVariable simboloVar = new SymbolVariable (scopeManager.getCurrentScope(), p.getNombre(), p.getTipo(), despl);
                                    despl++;
                                    // Creo lista ordenada de parametros en el PROCEDIMIENTO.
                                    tipoProcedimiento.setTypeParametro(p.getColumna(),p.getTipo()); 
                                    // Fijar paso parametros Ref/Valor en Symbolvar
                                    simboloVar.setReferencia(p.getReferencia());
                                    tablaSimbolos.addSymbol(p.getNombre(),simboloVar);                                  	
                                    tipoProcedimiento.setParametro(simboloVar);
                                } 
							    LabelFactoryIF lf = CompilerContext.getLabelFactory();
                                LabelIF labelInicio = lf.create();
                                tipoProcedimiento.setEtiqSub(labelInicio);
                                LabelIF labelFin = lf.create();
                                tipoProcedimiento.setEtiqSubFin(labelFin);
                              }
:} 
cuerpo:bloque2 {:
                                ScopeIF scope = scopeManager.getCurrentScope();
                                BloqueSentencias bloque = new BloqueSentencias();
                                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
								List code2 = bloque2.getIntermediateCode();
                                TypeProcedure tipoProc = (TypeProcedure) scopeManager.searchType(scope.getName());
                                cb.addQuadruple("INICIO_SUBPROG", tipoProc.getEtiqSub().getName());
								
								cb.addQuadruples (code2);
                                cb.addQuadruple("FIN_SUBPROG", tipoProc.getEtiqSub().getName(), tipoProc.getEtiqSubFin().getName(),new Value(tipoProc.getScope().getLevel()));
								List code=cb.create ();
								bloque.setIntermediateCode (code); 

                                // Cerramos Scope
                                desplScope.put(scope.getName(), new Integer(despl));
                                scopeManager.closeScope();

                                despl=((Integer)desplScope.get(scopeManager.getCurrentScope().getName())).intValue();
                                
                                semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
                                RESULT=bloque;
:};

// ----------------------------                     
// Definicion de SENTENCIAS		
// ---------------------------- 
listaSentencias::= sentencia:bloque {:
                  RESULT=bloque;
:}	| 
		sentencia:sent listaSentencias:blq {:
					BloqueSentencias bloque = new BloqueSentencias();
                    IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());
                    cb.addQuadruples(sent.getIntermediateCode());
                	cb.addQuadruples(blq.getIntermediateCode());
                	List code = cb.create();
                	bloque.setIntermediateCode(code);
					
                	 //semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
					RESULT=bloque;
:};

sentencia::=sentenciaAsignacion:sent {: RESULT=sent; :}| 
			sentenciaIf:sent {: RESULT=sent; :} | 
			sentenciaWhile:sent {: RESULT=sent; :} | 
			sentenciaPutLine:sent {: RESULT=sent; :} | 
			sentenciaProcedimiento:sent {: RESULT=sent;:} | 
			RETURN expresion:exp {:
				BloqueSentencias bloque = new BloqueSentencias(exp);
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);	
				List code1 = exp.getIntermediateCode();
				cb.addQuadruples (code1);
				cb.addQuadruple("RET",exp.getResultado());
				List code = cb.create();
                bloque.setIntermediateCode(code);
                
                semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
					RESULT=bloque;
:};

// ------------------------
// Sentencia PUTLINE
// ------------------------
sentenciaPutLine::= PUTLINE:id PARENTESISIZQ CARACTERESCADENA:cad PARENTESISDER PUNTOYCOMA
{:
     			BloqueSentencias bloque = new BloqueSentencias();
     			ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
				cadenas.add(cad.getLexema());
				cb.addQuadruple("WRSTR","cadena"+cadenas.size());
				List code = cb.create();
                bloque.setIntermediateCode(cb.create());
                
                semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
					RESULT=bloque;		
				:};

sentenciaPutLine::= PUTLINE:id PARENTESISIZQ expresion:exp PARENTESISDER PUNTOYCOMA
{:    
            BloqueSentencias bloque = new BloqueSentencias();
            ScopeIF scope = scopeManager.getCurrentScope();
            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
			cb.addQuadruples(exp.getIntermediateCode());
			
            if (exp.getTipo() instanceof TypeBoolean){ //Es un boolean
            	
		        if (exp.getResultado().toString().equals("0")){
		        	cadenas.add("\""+new Value(false).toString()+"\"");
		        	cb.addQuadruple("WRSTR","cadena"+cadenas.size());
		        }else if (exp.getResultado().toString().equals("1")){
		        	cadenas.add("\""+new Value(true).toString()+"\"");
		        	cb.addQuadruple("WRSTR","cadena"+cadenas.size());
		        }else{
		        	LabelFactoryIF lF = new LabelFactory ();
			        LabelIF l1 = lF.create ();
			        LabelIF l2 = lF.create ();
			       
			        cb.addQuadruple("CMP", exp.getResultado(), new Value(0)); //comparo si es falso
                    cb.addQuadruple("BNZ", l1);             // Salto si x!=0 --> Si no es falso
                    cb.addQuadruple ("INL", l2);
                    cadenas.add("\""+new Value(false).toString()+"\"");
		        	cb.addQuadruple("WRSTR","cadena"+cadenas.size());
		        	etiqueta.add(etiqueta.size()+1);
		        	cb.addQuadruple("BR", "etiqueta"+etiqueta.size());             // Salto incondicional
                    cb.addQuadruple("BZ", l2);             // Salto si x!=0 --> Si no es falso
                    cb.addQuadruple ("INL", l1);
                    cadenas.add("\""+new Value(true).toString()+"\"");
		        	cb.addQuadruple("WRSTR","cadena"+cadenas.size());
		        	cb.addQuadruple ("INL",  "etiqueta"+etiqueta.size());
		        }
		        
		    }else if (exp.getTipo() instanceof TypeArray){ //Es un Array
		    	TypeArray array = (TypeArray) exp.getTipo();
		    	if (array.getTipo() instanceof TypeBoolean){ //Es un array de tipo boolean
		    		//semanticErrorManager.semanticDebug("ARRAY de tipo BOOLEAN");
		    		
		    		LabelFactoryIF lF = new LabelFactory ();
			        LabelIF l1 = lF.create ();
			        LabelIF l2 = lF.create ();
		    		cb.addQuadruple("CMP", exp.getResultado(), new Value(0)); //comparo si es falso
                    cb.addQuadruple("BNZ", l1);             // Salto si x!=0 --> Si no es falso
                    cb.addQuadruple ("INL", l2);
                    cadenas.add("\""+new Value(false).toString()+"\"");
		        	cb.addQuadruple("WRSTR","cadena"+cadenas.size());
		        	etiqueta.add(etiqueta.size()+1);
		        	cb.addQuadruple("BR", "etiqueta"+etiqueta.size());             // Salto incondicional
                    cb.addQuadruple("BZ", l2);             // Salto si x!=0 --> Si no es falso
                    cb.addQuadruple ("INL", l1);
                    cadenas.add("\""+new Value(true).toString()+"\"");
		        	cb.addQuadruple("WRSTR","cadena"+cadenas.size());
		        	cb.addQuadruple ("INL",  "etiqueta"+etiqueta.size());
		    	
		    	}else{ //Es un array de tipo Integer
		    		//semanticErrorManager.semanticDebug("ARRAY de tipo INTEGER");   			
		    		cb.addQuadruple("WRINT", exp.getResultado());
		    	}
            }else{//Es un numero
            	cb.addQuadruple("WRINT", exp.getResultado());
            }
            
			List code = cb.create();
            bloque.setIntermediateCode(cb.create());
            
            semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
			RESULT=bloque;
	   :}; 
	   
sentenciaPutLine::= PUTLINE:id PARENTESISIZQ vector:vect PARENTESISDER PUNTOYCOMA
{:    
            BloqueSentencias bloque = new BloqueSentencias();
            ScopeIF scope = scopeManager.getCurrentScope();
            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
			cb.addQuadruples(vect.getIntermediateCode());
			
            if (vect.getTipo() instanceof TypeArray){ //Es un Array
		    	TypeArray array = (TypeArray) vect.getTipo();
		    	if (array.getTipo() instanceof TypeBoolean){ //Es un array de tipo boolean
		    		//semanticErrorManager.semanticDebug("ARRAY de tipo BOOLEAN");
		    		
		    		LabelFactoryIF lF = new LabelFactory ();
			        LabelIF l1 = lF.create ();
			        LabelIF l2 = lF.create ();
			        cb.addQuadruple("CMP", vect.getResultado(), new Value(0)); //comparo si es falso
                    cb.addQuadruple("BNZ", l1);             // Salto si x!=0 --> Si no es falso
                    cb.addQuadruple ("INL", l2);
                    cadenas.add("\""+new Value(false).toString()+"\"");
		        	cb.addQuadruple("WRSTR","cadena"+cadenas.size());
		        	etiqueta.add(etiqueta.size()+1);
		        	cb.addQuadruple("BR", "etiqueta"+etiqueta.size());             // Salto incondicional
                    cb.addQuadruple("BZ", l2);             // Salto si x!=0 --> Si no es falso
                    cb.addQuadruple ("INL", l1);
                    cadenas.add("\""+new Value(true).toString()+"\"");
		        	cb.addQuadruple("WRSTR","cadena"+cadenas.size());
		        	cb.addQuadruple ("INL",  "etiqueta"+etiqueta.size());
		    	
		    	}else{ //Es un array de tipo Integer
		    		//semanticErrorManager.semanticDebug("ARRAY de tipo INTEGER");
		    		
		    		TemporalFactoryIF tf = new TemporalFactory(scope);
		    		Temporal temporal = (Temporal) tf.create(); 
                    temporal.setDesplazamiento(despl);
                    despl++;
		    		vect.setResultado(temporal); 			
		    		cb.addQuadruple("WRINT_ARRAY", temporal);
		    	}
           }
            
			List code = cb.create();
            bloque.setIntermediateCode(cb.create());
            semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
			RESULT=bloque;
	   :}; 
// ------------------------
// Sentencia WHILE
// ------------------------
sentenciaWhile::= WHILE:id expresion:exp LOOP listaSentencias:sent END LOOP PUNTOYCOMA{:

		semanticErrorManager.semanticInfo("Sentencia WHILE en [" + id.getLine() + ":" + id.getColumn() + "]");
                              if ( !(exp.getTipo().getName().equals("BOOLEAN")) )
                                    semanticErrorManager.semanticFatalError ("La expresion sentencia WHILE no es BOOLEANA.");
                              BloqueSentencias bloque = new BloqueSentencias();
                              ScopeIF scope = scopeManager.getCurrentScope();
								
							  IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                              TemporalFactoryIF tf = new TemporalFactory(scope);				
                              Temporal temporal = (Temporal) tf.create(); 
                              temporal.setDesplazamiento(despl);
                              despl++;
                                    
                              LabelFactoryIF lf = CompilerContext.getLabelFactory();					
                              LabelIF INICIO_BUCLE = lf.create();
                              LabelIF FIN_BUCLE= lf.create();				
                        	
                              bloque.setResultado(temporal);
                              
                              semanticErrorManager.semanticDebug("exp: "+exp.getIntermediateCode());
                              
                              cb.addQuadruple("INL", INICIO_BUCLE);
                              cb.addQuadruples(exp.getIntermediateCode());
                              cb.addQuadruple("CMP", exp.getResultado(), new Value(0));
                              cb.addQuadruple("BZ", FIN_BUCLE);
                              cb.addQuadruples(sent.getIntermediateCode()); 
                              cb.addQuadruple("BP", INICIO_BUCLE);           // Salto si NO negativo
                              cb.addQuadruple("INL", FIN_BUCLE);
                              
                              List code = cb.create();
                              bloque.setIntermediateCode(code);
                             
                              semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
                              RESULT=bloque;
                            :};

// ------------------------
// Sentencia IF
// ------------------------
sentenciaIf::= IF:id expresion:exp THEN listaSentencias:sent END IF PUNTOYCOMA
{:
					//semanticErrorManager.semanticInfo ("Sentencia IF simple en [" +id.getLine() + ":" + id.getColumn()+"]");
                            if ( !(exp.getTipo().getName().equals("BOOLEAN")) ) 
                                  semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es LOGICA.");
                                  BloqueSentencias bloque = new BloqueSentencias();
				  				  ScopeIF scope = scopeManager.getCurrentScope();
				  				  
				  				  IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);

                                  LabelFactoryIF lf = CompilerContext.getLabelFactory();
                                  LabelIF LFALSE = lf.create();

                                  cb.addQuadruples(exp.getIntermediateCode());
                                  cb.addQuadruple("CMP", exp.getResultado(), new Value(1));
	    			  			  cb.addQuadruple("BNZ",LFALSE);   // Salto negativo
					 			  cb.addQuadruples(sent.getIntermediateCode());
								  cb.addQuadruple("INL", LFALSE);
                                  cb.addQuadruple ("NOP", null);
                                  List code = cb.create();
                                  bloque.setIntermediateCode(code);
                                  
                                  semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
                                  RESULT=bloque;

					:};
sentenciaIf::= IF:id expresion:exp THEN listaSentencias:sent1 ELSE listaSentencias:sent2 END IF PUNTOYCOMA
{:
			                 if ( !(exp.getTipo().getName().equals("BOOLEAN")) ) 
                                semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es LOGICA.");
                                BloqueSentencias bloque = new BloqueSentencias();
								ScopeIF scope = scopeManager.getCurrentScope();
								IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
				
								LabelFactoryIF lf = CompilerContext.getLabelFactory();
								LabelIF LTRUE = lf.create();
								LabelIF LFALSE = lf.create();
								
                                cb.addQuadruples(exp.getIntermediateCode());
                                cb.addQuadruple("CMP", exp.getResultado(), new Value(1));
								cb.addQuadruple("BNZ",LFALSE);   // Salto no cero
								cb.addQuadruples(sent1.getIntermediateCode());
								cb.addQuadruple("BR",LTRUE);  // Salto incondicional
								cb.addQuadruple("INL", LFALSE);
								cb.addQuadruples(sent2.getIntermediateCode());
								cb.addQuadruple("INL", LTRUE);
                                cb.addQuadruple("NOP", null);
                                List code = cb.create();
                                bloque.setIntermediateCode(code);

							    semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
                                RESULT=bloque;
				:};

// ------------------------
// Sentencia ASIGNACION
// ------------------------
sentenciaAsignacion::= ID:id ASIGNACION expresion:exp PUNTOYCOMA
{:
							//semanticErrorManager.semanticInfo ("Sentencia ASIGNACION " + id.getLexema() + ":= " + exp.getTipo().getName()+" en [" +id.getLine() + ":" + id.getColumn()+"]");
							BloqueSentencias bloque = new BloqueSentencias();
                            ScopeIF scope = scopeManager.getCurrentScope();
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                            
                            // Hay que tener en cuenta que puede ser el ID de una funcion
                            if (!(scopeManager.containsSymbol(id.getLexema()))) {
                                semanticErrorManager.semanticFatalError ("La variable: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                            } else {
								SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
									// Comprobamos que no es una constante
									if (simbolo instanceof SymbolConstant)
                                    semanticErrorManager.semanticFatalError ("276. La constante: " + id.getLexema() +" en [" + 
                                    id.getLine() + ":" + id.getColumn() + "] no admite asignaciones.");
                                    
                                  	TypeIF tipo = exp.getTipo();
                                  
                                    // Comprobaciones en el caso de una funcion	
	                                if (tipo instanceof TypeFunction ) {

                                    TypeFunction tipoFuncion = (TypeFunction) tipo;
                                    // El tipo de retorno debe ser igual que la expresion
                                     
                                    if ( !(tipoFuncion.getTipoRetorno() == exp.getTipo()) ) 
                                        semanticErrorManager.semanticFatalError ("El tipo retorno funcion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no coincide con la expresion.");
                                     // Es una funcion y si hay asignacion de retorno
                                     tipoFuncion.setHayRetorno(true);
                                     
                                     Variable var = new Variable(id.getLexema(), scope);
                                     var.setAmbito(tipo.getScope());
                                     LabelIF label = tipoFuncion.getEtiqSubFin();
                                     var.setEtiqRetorno(label);
                                     List code1 = exp.getIntermediateCode();
                                     cb.addQuadruples (code1);
                                
                                     cb.addQuadruple("RET", var, exp.getResultado());

                                } 
                                
                           			// Creamos codigo para la sentencia 
                                    Variable var = new Variable(id.getLexema(), scope);
                                    var.setAmbito(simbolo.getScope());
                                    List code1 = exp.getIntermediateCode();
                                    cb.addQuadruples (code1);
                                    cb.addQuadruple("MV", var, exp.getResultado()); 
                                
                               	List code = cb.create();
                                bloque.setIntermediateCode(code);
                                
                               	semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
                                RESULT=bloque;
					
                             }
                		:};//x:=t-r;   z:= resta (a,b);

sentenciaAsignacion::= ID:id PUNTO ID:campo ASIGNACION expresion:exp PUNTOYCOMA {:

					semanticErrorManager.semanticInfo ("Sentencia ASIGNACION " + id.getLexema() + ":= " + exp.getTipo().getName()+" en [" +id.getLine() + ":" + id.getColumn()+"]");
			
                            if ( !(scopeManager.containsSymbol(id.getLexema())) ) {
                                semanticErrorManager.semanticFatalError ("La variable: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                            } else {
	                        SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                                TypeIF tipo = scopeManager.searchType(simbolo.getType().getName());

				
                                    ScopeIF scope = scopeManager.getCurrentScope();                     
                                    BloqueSentencias bloque = new BloqueSentencias();		
                                    //semanticErrorManager.semanticDebug(bloque.getIntermediateCode());	
                                    RESULT=bloque;						
                    		}
				:};

sentenciaAsignacion::= ID PUNTO ID PUNTO ID ASIGNACION expresion PUNTOYCOMA;

sentenciaAsignacion::= ID:id PARENTESISIZQ ENTERO:num PARENTESISDER ASIGNACION expresion:exp PUNTOYCOMA
{:
							semanticErrorManager.semanticInfo ("Sentencia ASIGNACION " + id.getLexema() + ":= " + exp.getTipo().getName()+" en [" +id.getLine() + ":" + id.getColumn()+"]");
			
                            ScopeIF scope = scopeManager.getCurrentScope();
                            BloqueSentencias bloque = new BloqueSentencias();
                            // Existe la variable vector
                            if (!(scopeManager.containsSymbol(id.getLexema())) ) 
                                semanticErrorManager.semanticFatalError ("El VECTOR: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no ha sido definido.");
                            
                            SymbolVariable simbolo = (SymbolVariable) scopeManager.searchSymbol(id.getLexema());
                            
                            // Existe la var y es del tipo vector
                            if (! (simbolo.getType() instanceof TypeArray)) 
                                semanticErrorManager.semanticFatalError ("El ID: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es un tipo CONJUNTO.");
                           
                            // Asignacion entre limites
                            
                            TypeArray tipoArray = (TypeArray) simbolo.getType();
                            int n = Integer.parseInt(num.getLexema());
                            if (n < tipoArray.getValIni() || n > tipoArray.getValFin())
                                semanticErrorManager.semanticFatalError ("El rango del vector: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no esta dentro de los limites del mismo.");

                          	semanticErrorManager.semanticInfo ("El valor '"+ num.getLexema() + "' esta dentro de los limites ["+tipoArray.getValIni()+","+tipoArray.getValFin()+"]");
                           	
                           	// Comprobacion de tipos (vector y expresion)
							if ( !(simbolo.getType().getName().equalsIgnoreCase(exp.getTipo().getName())) ) {	
								TypeIF tipoVar=scopeManager.searchType(simbolo.getType().getName());
 
                        		if (!(simbolo.getType().getName().equalsIgnoreCase(tipoVar.getName()))) { 
                        			semanticErrorManager.semanticFatalError ("El ID: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no son compatibles.");
                           		}else{	
                           			
					      			TemporalFactory tF = new TemporalFactory(scope);
					      			IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
					      			
					      			int dimArray = tipoArray.getValFin()-tipoArray.getValIni()+1;
					      		
					      			OperandIF tempExp = exp.getResultado();
					      			cb.addQuadruples (exp.getIntermediateCode());
					      		
					      			Variable var = new Variable(id.getLexema(), scope);
                                    var.setAmbito(tipoArray.getScope());
                                    var.setSize(dimArray);
                                    List code1 = exp.getIntermediateCode();
                                    cb.addQuadruples (code1);
					      			
					      			cb.addQuadruple ("ASIGN_VECTOR",var,num.getLexema(),exp.getResultado());
					      			
					      			bloque.setResultado(tempExp);
					      			bloque.setIntermediateCode(cb.create());
                          		}
                            }
                            semanticErrorManager.semanticDebug("ASIGNACION VECTORES");
                              semanticErrorManager.semanticDebug(bloque.getIntermediateCode());					
                            RESULT = bloque;
                        :}; //vE(1):=20;


////vector::= ID:id PARENTESISIZQ ENTERO:num PARENTESISDER;

// ------------------------
// Sentencia FUNCION
// ------------------------
sentenciaFuncion ::= ID:idFunc PARENTESISIZQ lista_parametros_llamada:listaPar PARENTESISDER
{:
					//semanticErrorManager.semanticInfo("Sentencia FUNCION en la linea: "+idFunc.getLine()+ " y columna "+idFunc.getColumn());
	                    
 					ScopeIF scope = scopeManager.getCurrentScope();
            		    SymbolTableIF tablaSimbolos = scope.getSymbolTable();
                            TypeTableIF tablaTipos = scope.getTypeTable();
			    
                            // Si la funcion ha sido declarada
		      	    if (!(scopeManager.containsSymbol(idFunc.getLexema()))) 
                                semanticErrorManager.semanticFatalError("340. La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" NO ha sido declarada");
	                    
                            // Si es un tipo Funcion
                            SymbolIF func = scopeManager.searchSymbol(idFunc.getLexema());
                            if (! (func.getType() instanceof TypeFunction) )
				    semanticErrorManager.semanticFatalError("La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" NO es un FUNCTION");
	            	        
            		    // num de parametros sea el mismo que argumentos y sea correcto por REF/Valor
	            	    TypeFunction tipoFunc = (TypeFunction) func.getType();
                            ListaObjetos lista = new ListaObjetos(listaPar);

                            // Coincidencia de Tipos y numero entre la Def de la funcion y la llamada
		  	    		if (!tipoFunc.comparaParametros(listaPar)) 
                                  semanticErrorManager.semanticFatalError ("El num. de parametros no coincide en tipos o numero para la funci�n " + idFunc.getLexema() + " [" + idFunc.getLine() + ":" + idFunc.getColumn() + "]");
            		    
                            Expresion exp = new Expresion(tipoFunc.getTipoRetorno(), idFunc.getLine(), idFunc.getColumn());
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
                            
                            // Temporal para el retorno
                            TemporalFactoryIF tf = new TemporalFactory(scope);				
                            Temporal temporal = (Temporal) tf.create(); // Temporal donde se almacenara retorno
                            temporal.setDesplazamiento(despl);
                            despl++;
                            exp.setResultado(temporal);
                            
                            // Obtener desplazamiento Funci�n
                            int desplFunc=((Integer)desplScope.get(idFunc.getLexema())).intValue();
                            Value valor = new Value(desplFunc);
                            List lista1 = tipoFunc.getListaParametros();
                                     
                            cb.addQuadruple("INICIO_ARGUMENTOS", null, null, null);
					
			    for (int i=listaPar.size()-1;i>=0; i--){
                                SymbolVariable s = (SymbolVariable) lista1.get(listaPar.size()-i-1);
                                int d = s.getDesplazamiento();
                                Expresion expPar = (Expresion) listaPar.get(i);
                                cb.addQuadruples(expPar.getIntermediateCode());
                                if ( s.getReferencia() ) {
                                    if ( !expPar.getReferencia())
                                        semanticErrorManager.semanticFatalError ("El par�metro es por referencia y no admite expresiones." + idFunc.getLexema() + " [" + idFunc.getLine() + ":" + idFunc.getColumn() + "]");
                                    cb.addQuadruple("ARGUMENTO_REF", expPar.getResultado(), new Value(d));
                                 }else{
                                    cb.addQuadruple("ARGUMENTO", expPar.getResultado(), new Value(d));
                                 }
                            }
                            Variable var = new Variable(idFunc.getLexema());
                            LabelFactoryIF lf = CompilerContext.getLabelFactory();
                            LabelIF label = lf.create();
                            var.setEtiqRetorno(label);
                            var.setEtiqSub(tipoFunc.getEtiqSub());
                            cb.addQuadruple ("CALL", var, new Value(tipoFunc.getScope().getLevel()), temporal);
                            exp.setIntermediateCode(cb.create());
                            
                            semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
                            RESULT=exp;
			:};

lista_parametros_llamada::= expresion:exp {:
                ListaObjetos lista = new ListaObjetos();
			    lista.add(exp);
                RESULT=lista; :};
lista_parametros_llamada::= expresion:exp COMA lista_parametros_llamada:listaPar {:
                            ListaObjetos lista = new ListaObjetos(listaPar);
                            lista.add(exp);
                            RESULT=lista;
                            :};

// ------------------------
// Sentencia PROCEDIMIENTO
// ------------------------
//sentenciaProcedimiento::= idTipos ASIGNACION ID PARENTESISIZQ lista_parametros_llamada PARENTESISDER PUNTOYCOMA;
sentenciaProcedimiento::= ID:idProc PARENTESISIZQ lista_parametros_llamada:listaPar PARENTESISDER PUNTOYCOMA
						{:
						
						 semanticErrorManager.semanticInfo("Sentencia PROCEDIMIENTO "+idProc.getLexema()+" en la linea: "+idProc.getLine());
						
                            ScopeIF scope = scopeManager.getCurrentScope();
	         	    		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
	                    	TypeTableIF tablaTipos = scope.getTypeTable();
				
                            // Si Procedimiento ha sido declarado
		      	    		if (!(scopeManager.containsSymbol(idProc.getLexema()))) 
                                semanticErrorManager.semanticFatalError("El procedimiento "+idProc.getLexema()+" en la linea: "+idProc.getLine()+" NO ha sido declarada");

                            // Si es un tipo Procedure    
                            SymbolIF proc = scopeManager.searchSymbol(idProc.getLexema());
                            TypeIF tipo = scopeManager.searchType(idProc.getLexema());
                            if (! (tipo instanceof TypeProcedure) )
                                        semanticErrorManager.semanticFatalError("El ID "+idProc.getLexema()+" en la linea: "+idProc.getLine()+" NO es un PROCEDIMIENTO");
	            
                            // num de parametros sea el mismo que argumentos y sea correcto por REF/VALOR
	            	    	TypeProcedure tipoProc = (TypeProcedure) proc.getType();
                            ListaObjetos lista = new ListaObjetos(listaPar);

                            // Coincidencia de Tipos y numero entre la Def del procedimiento y la llamada
                            if (!tipoProc.comparaParametros(listaPar)) 
                                semanticErrorManager.semanticFatalError ("El num. de parametros no coincide en para el procedimiento " + idProc.getLexema() + " [" + idProc.getLine() + ":" + idProc.getColumn() + "]");
            		    
                            BloqueSentencias bloque = new BloqueSentencias();
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                            // Obtener desplazamiento Procedimiento
                            int desplProc=((Integer)desplScope.get(idProc.getLexema())).intValue();
                            Value valor = new Value(desplProc);
                            List lista1 = tipoProc.getListaParametros();

                            cb.addQuadruple("INICIO_ARGUMENTOS", null, null, null);

                            for (int i=listaPar.size()-1;i>=0; i--) {
                                SymbolVariable s = (SymbolVariable) lista1.get(listaPar.size()-i-1);
                                int d = s.getDesplazamiento();
                                Expresion expPar = (Expresion) listaPar.get(i);
                                cb.addQuadruples(expPar.getIntermediateCode());
                                if ( s.getReferencia() ) {
                                    if ( !expPar.getReferencia())
                                        semanticErrorManager.semanticFatalError ("El parametro es por referencia y no admite expresiones." + idProc.getLexema() + " [" + idProc.getLine() + ":" + idProc.getColumn() + "]");
                                    cb.addQuadruple("ARGUMENTO_REF", expPar.getResultado(), new Value(d));
                                 }else{
                                    cb.addQuadruple("ARGUMENTO", expPar.getResultado(), new Value(d));
                                 }
                            }
                            Variable var = new Variable(idProc.getLexema());
                            LabelFactoryIF lf = CompilerContext.getLabelFactory();
                            LabelIF label = lf.create();
                            var.setEtiqRetorno(label);
                            var.setEtiqSub(tipoProc.getEtiqSub());

                            // No hay retorno, se pasa valor cero en operando2
                            cb.addQuadruple ("CALL", var, new Value(tipoProc.getScope().getLevel()), new Value(0));
                            bloque.setIntermediateCode(cb.create());
                            
                              semanticErrorManager.semanticDebug(bloque.getIntermediateCode());	
                              RESULT=bloque;	
                            :};

// --------------------
// Expresion 
// --------------------
expresion::=expresion:exp1 MENOS:id expresion:exp2
{:
						    Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                            if (exp.castingTipos(exp1 , exp2) ) {
                                 semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            }else{
                            	ScopeIF scope = scopeManager.getCurrentScope();
                            	TemporalFactoryIF tf = new TemporalFactory(scope);				
								Temporal temporal = (Temporal) tf.create(); 
								temporal.setDesplazamiento(despl);
								despl++;        
								IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
								List code1 = exp1.getIntermediateCode();
								List code2 = exp2.getIntermediateCode();
								cb.addQuadruples (code1);
								cb.addQuadruples (code2);
							
								cb.addQuadruple ("SUB", temporal, exp1.getResultado(), exp2.getResultado()); // temporal <- exp1 - exp2
								List code=cb.create ();
								exp.setResultado(temporal);  
								exp.setIntermediateCode(code); 
								
                                semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
								RESULT=exp;
                             }

					:}; 
expresion::= expresion:exp1 MAS:id expresion:exp2
{:
					semanticErrorManager.semanticInfo("OPERACION SUMA");	
                            ScopeIF scope = scopeManager.getCurrentScope();
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                            Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                            TemporalFactoryIF tf = new TemporalFactory(scope);				
                            Temporal temporal = (Temporal) tf.create(); 
                            
                            temporal.setDesplazamiento(despl);
                            despl++;
                            List code1 = exp1.getIntermediateCode();
                            List code2 = exp2.getIntermediateCode();
                            cb.addQuadruples (code1);
                            cb.addQuadruples (code2);
                            cb.addQuadruple ("ADD", temporal, exp1.getResultado(), exp2.getResultado()); // temporal <-exp1 + exp2
				
							List code=cb.create ();
                            exp.setResultado (temporal); 
                            exp.setIntermediateCode (code); 
                           
                           	semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
                            RESULT=exp;
                            :} | 
			expresion:exp1 OR:id expresion:exp2 {:
                            if ( !(exp1.getTipo() == exp2.getTipo()) || !(exp1.getTipo().getName().equals("BOOLEAN")) || !(exp2.getTipo().getName().equals("BOOLEAN")) ) {
                                semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            }else{
		      	        		Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
								ScopeIF scope = scopeManager.getCurrentScope();
				
                                TemporalFactoryIF tf = new TemporalFactory(scope);;				
                                Temporal temporal = (Temporal) tf.create(); 
                               	temporal.setDesplazamiento(despl);
								despl++;
			
								IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
								List code1 = exp1.getIntermediateCode();
								List code2 = exp2.getIntermediateCode();
								cb.addQuadruples (code1);
								cb.addQuadruples (code2);

                                Value verdad = new Value(1);
                                Value falso = new Value(0);
        						LabelFactoryIF lf = CompilerContext.getLabelFactory();					
                                LabelIF LTRUE = lf.create();
        						LabelIF LFIN = lf.create();				

                                cb.addQuadruple ("CMP", verdad, exp1.getResultado()); 
                                cb.addQuadruple ("BZ", LTRUE); 
                                cb.addQuadruple ("CMP", verdad, exp2.getResultado()); 
                                cb.addQuadruple ("BZ", LTRUE); 
                                cb.addQuadruple ("MV", temporal, falso);
                                cb.addQuadruple ("BR", LFIN); 
                                cb.addQuadruple ("INL", LTRUE);
                                cb.addQuadruple ("MV", temporal, verdad);
                                cb.addQuadruple ("INL", LFIN);
                                
								List code=cb.create ();
								exp.setResultado (temporal); 
								exp.setIntermediateCode (code); 
        			
              
					semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
                    RESULT=exp;
                            }
        		:}| 
			expresion:exp1 AND:id expresion:exp2 {:
                            if ( !(exp1.getTipo() == exp2.getTipo()) || !(exp1.getTipo().getName().equals("BOOLEAN")) || !(exp2.getTipo().getName().equals("BOOLEAN")) ) {
                                semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            }else{
				      	        Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
								ScopeIF scope = scopeManager.getCurrentScope();
								TemporalFactoryIF tf = new TemporalFactory(scope);				
		                        Temporal temporal = (Temporal) tf.create(); 
                                temporal.setDesplazamiento(despl);
								despl++;
			
								IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
								List code1 = exp1.getIntermediateCode();
								List code2 = exp2.getIntermediateCode();
								cb.addQuadruples (code1);
								cb.addQuadruples (code2);

                                Value verdad = new Value(1);
                                Value falso = new Value(0);
        						LabelFactoryIF lf = CompilerContext.getLabelFactory();					
                                LabelIF LTRUE_1 = lf.create();
                                LabelIF LTRUE_2 = lf.create();
        						LabelIF LFIN = lf.create();				

                                cb.addQuadruple ("CMP", verdad, exp1.getResultado()); 
                                cb.addQuadruple ("BZ", LTRUE_1); 
                                cb.addQuadruple ("MV", temporal, falso);
                                cb.addQuadruple ("BR", LFIN); 
                                cb.addQuadruple ("INL", LTRUE_1);
                                cb.addQuadruple ("CMP", verdad, exp2.getResultado()); 
                                cb.addQuadruple ("BZ", LTRUE_2); 
                                cb.addQuadruple ("MV", temporal, falso);
                                cb.addQuadruple ("BR", LFIN); 
                                cb.addQuadruple ("INL", LTRUE_2);
                                cb.addQuadruple ("MV", temporal, verdad);
                                cb.addQuadruple ("INL", LFIN);
                                
				List code=cb.create ();
				exp.setResultado (temporal); 
				exp.setIntermediateCode (code); 
        		
					semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
                    RESULT=exp;
                            }
        		:} | 
			expresion:exp1 MAYORQUE:id expresion:exp2 
{:
			    if ( !(exp1.getTipo() == exp2.getTipo())  ||  !(exp1.getTipo().getName().equals("INTEGER"))  || !(exp2.getTipo().getName().equals("INTEGER")) )  {
                                  semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			     }else{
			      	          	  Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
					  			  ScopeIF scope = scopeManager.getCurrentScope();
				 				  TemporalFactoryIF tf = new TemporalFactory(scope);				
                                  Temporal temporal = (Temporal) tf.create(); 
                                  temporal.setDesplazamiento(despl);
								  despl++;
                                  
								  IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
								  List code1 = exp1.getIntermediateCode();
								  List code2 = exp2.getIntermediateCode();
								  cb.addQuadruples (code1);
								  cb.addQuadruples (code2);
                                  Value verdad = new Value(1);
                                  Value falso = new Value(0);
        			  			  LabelFactoryIF lf = CompilerContext.getLabelFactory();					
                                  LabelIF LTRUE = lf.create();
        			  				LabelIF LFIN = lf.create();				
                                  // Hacemos cmp al reves para contemplar caso ambos iguales
                                  cb.addQuadruple ("CMP", exp2.getResultado(), exp1.getResultado()); 
                                  cb.addQuadruple ("BN", LTRUE); 
                                  cb.addQuadruple ("MV", temporal, falso);
                                  cb.addQuadruple ("BR", LFIN);
                                  cb.addQuadruple ("INL", LTRUE);
                                  cb.addQuadruple ("MV", temporal, verdad);
                                  cb.addQuadruple ("INL", LFIN);
                                
				  List code=cb.create ();
				  exp.setResultado (temporal); 
				  exp.setIntermediateCode (code); 
				  
				  semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
				  RESULT=exp;
				}
					:} | 
			expresion:exp1 MENORQUE:id expresion:exp2 
{:
			    if ( !(exp1.getTipo() == exp2.getTipo())  ||  !(exp1.getTipo().getName().equals("INTEGER"))  || !(exp2.getTipo().getName().equals("INTEGER")) )  {
                                  semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			     }else{
		      	          		  Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
				  				  ScopeIF scope = scopeManager.getCurrentScope();
				 				  TemporalFactoryIF tf = new TemporalFactory(scope);				
                                  Temporal temporal = (Temporal) tf.create(); 
                                  temporal.setDesplazamiento(despl);
								  despl++;
                                  
								  IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
								  List code1 = exp1.getIntermediateCode();
								  List code2 = exp2.getIntermediateCode();
								  cb.addQuadruples (code1);
								  cb.addQuadruples (code2);
                                  Value verdad = new Value(1);
                                  Value falso = new Value(0);
        			  			  LabelFactoryIF lf = CompilerContext.getLabelFactory();					
                                  LabelIF LTRUE = lf.create();
        			  			  LabelIF LFIN = lf.create();				
                                  // Hacemos cmp al reves para contemplar caso ambos iguales
                                  cb.addQuadruple ("CMP", exp1.getResultado(), exp2.getResultado()); 
                                  cb.addQuadruple ("BN", LTRUE); 
                                  cb.addQuadruple ("MV", temporal, falso);
                                  cb.addQuadruple ("BR", LFIN);
                                  cb.addQuadruple ("INL", LTRUE);
                                  cb.addQuadruple ("MV", temporal, verdad);
                                  cb.addQuadruple ("INL", LFIN);
                                
								  List code=cb.create ();
								  exp.setResultado (temporal); 
								  exp.setIntermediateCode (code); 
						
					semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
				  	RESULT=exp;
				}
					:} | 
			expresion:exp1 IGUALQUE:id expresion:exp2 {:
                            if ( !(exp1.getTipo() == exp2.getTipo()) )
                                  semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                           
                            Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                            ScopeIF scope = scopeManager.getCurrentScope();
                            TemporalFactoryIF tf = new TemporalFactory(scope);				
                            Temporal temporal = (Temporal) tf.create(); 
                            temporal.setDesplazamiento(despl);
                            despl++;
                            
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                            List code1 = exp1.getIntermediateCode();
                            List code2 = exp2.getIntermediateCode();
                            cb.addQuadruples (code1);
                            cb.addQuadruples (code2);
                            Value verdad = new Value(1);
                            Value falso = new Value(0);
                            LabelFactoryIF lf = CompilerContext.getLabelFactory();					
                            LabelIF LTRUE = lf.create();
                            LabelIF LFIN = lf.create();
                            cb.addQuadruple ("CMP", exp1.getResultado(), exp2.getResultado()); 
                            cb.addQuadruple ("BN", LTRUE); 
                            cb.addQuadruple ("MV", temporal, falso);
                            cb.addQuadruple ("BR", LFIN);
                            cb.addQuadruple ("INL", LTRUE);
                            cb.addQuadruple ("MV", temporal, verdad);
                            cb.addQuadruple ("INL", LFIN);

                            List code=cb.create ();
                            exp.setResultado (temporal); 
                            exp.setIntermediateCode (code); 
                            
                            semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
				  			RESULT=exp;
                  	:} | 
			expresion:exp1 DISTINTOQUE:id expresion:exp2
			{:
                            if ( !(exp1.getTipo() == exp2.getTipo()) )
                                  semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            
                            Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                            ScopeIF scope = scopeManager.getCurrentScope();
                           
                            TemporalFactoryIF tf = new TemporalFactory(scope);				
                            Temporal temporal = (Temporal) tf.create(); 
                            temporal.setDesplazamiento(despl);
                            despl++;
                            
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                            List code1 = exp1.getIntermediateCode();
                            List code2 = exp2.getIntermediateCode();
                            cb.addQuadruples (code1);
                            cb.addQuadruples (code2);
                            Value verdad = new Value(1);
                            Value falso = new Value(0);
                            LabelFactoryIF lf = CompilerContext.getLabelFactory();					
                            LabelIF LTRUE = lf.create();
                            LabelIF LFIN = lf.create();
                            cb.addQuadruple ("CMP", exp1.getResultado(), exp2.getResultado()); 
                            cb.addQuadruple ("BNZ", LTRUE); 
                            cb.addQuadruple ("MV", temporal, falso);
                            cb.addQuadruple ("BR", LFIN);
                            cb.addQuadruple ("INL", LTRUE);
                            cb.addQuadruple ("MV", temporal, verdad);
                            cb.addQuadruple ("INL", LFIN);

                            List code=cb.create ();
                            exp.setResultado (temporal); 
                            exp.setIntermediateCode (code); 
                            
                            semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
				  			RESULT=exp;
                            :} | 
			PARENTESISIZQ expresion:exp PARENTESISDER {: 
					//semanticErrorManager.semanticDebug(exp.getIntermediateCode());
					RESULT=exp; 
                            :}; //Vector
expresion::= ID:id
{:
				ScopeIF scope = scopeManager.getCurrentScope();
			        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
                  		TypeTableIF tablaTipos = scope.getTypeTable();
			        if (!(scopeManager.containsSymbol(id.getLexema()))) {
                                    semanticErrorManager.semanticFatalError ("La variable: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                    		} else {
                                    SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                                    Expresion exp = new Expresion(simbolo.getType(), id.getLine(), id.getColumn());
                                    if (simbolo instanceof SymbolConstant) {
					SymbolConstant simboloCte = (SymbolConstant) simbolo;
					Value valor=new Value(simboloCte.getValue());
                                        exp.setResultado(valor);
				    }else{
                               			Variable var = new Variable(id.getLexema(), scope);
                                        var.setAmbito(simbolo.getScope());
                                        exp.setReferencia(true);
				        				exp.setResultado(var);       
				       
                                    }
                                //semanticErrorManager.semanticDebug(exp.getIntermediateCode());
                       		    RESULT = exp;
                    		}
                		:};
expresion::= ENTERO:num {:
                            ScopeIF scope = scopeManager.getCurrentScope();
	      	            	Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), num.getLine(), num.getColumn());
			    			Value resultado=new Value(Integer.parseInt(num.getLexema()));
                            exp.setResultado(resultado);  // Guardamos el valor operador
                
			                //semanticErrorManager.semanticDebug(exp.getIntermediateCode());
						    RESULT = exp;
			                            :}|
			ID:id PUNTO ID:campo {:
			    if ( !(scopeManager.containsSymbol(id.getLexema())) ) {
                                  semanticErrorManager.semanticFatalError ("El tipo registro: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                            }
                            ScopeIF scope = scopeManager.getCurrentScope();
                            SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                                                    
                            Expresion exp = new Expresion();

                            semanticErrorManager.semanticDebug(exp.getIntermediateCode());
						    RESULT = exp;
                		:}|
			ID PUNTO ID PUNTO ID  |
			sentenciaFuncion:exp {:
                                RESULT=exp;									
                            :} |
			tipoBooleano :id {:
                            ScopeIF scope = scopeManager.getCurrentScope();
	      	            	Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                            // Le damos el valor true=1 y false=0
                            Value resultado=new Value(0);
                            if (id.getLexema().equalsIgnoreCase("TRUE")){
								resultado=new Value(1);
                            }
							exp.setResultado(resultado);
							
                                RESULT=exp;			
                         :};
vector::= ID:id PARENTESISIZQ ENTERO:num PARENTESISDER {:
					ScopeIF scope = scopeManager.getCurrentScope();
			        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
                  		TypeTableIF tablaTipos = scope.getTypeTable();
			        if (!(scopeManager.containsSymbol(id.getLexema()))) {
                                    semanticErrorManager.semanticFatalError ("La variable: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                    } else {
                                    SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                                    Expresion exp = new Expresion(simbolo.getType(), id.getLine(), id.getColumn());

                                    // Existe la var y es del tipo vector
                            if (! (simbolo.getType() instanceof TypeArray)) 
                                semanticErrorManager.semanticFatalError ("El ID: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es un tipo CONJUNTO.");
                            
                            semanticErrorManager.semanticInfo ("VECTOR--> "+id.getLexema()+" de tipo : "+ simbolo.getType().getName());
                            
                            // Asignacion entre limites
                            TypeArray tipoArray = (TypeArray) simbolo.getType();
                            int n = Integer.parseInt(num.getLexema());
                            if (n < tipoArray.getValIni() || n > tipoArray.getValFin())
                                semanticErrorManager.semanticFatalError ("El rango del vector: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no esta dentro de los limites del mismo.");

                          	semanticErrorManager.semanticInfo ("El valor '"+ num.getLexema() + "' esta dentro de los limites ["+tipoArray.getValIni()+","+tipoArray.getValFin()+"]");
                           	
                           	// Comprobacion de tipos (vector y expresion)
						if ( !(simbolo.getType().getName().equalsIgnoreCase(exp.getTipo().getName())) ) {	
							TypeIF tipoVar=scopeManager.searchType(simbolo.getType().getName());
                        	if ( !(simbolo.getType().getName().equalsIgnoreCase(tipoVar.getName())))  
                                        semanticErrorManager.semanticFatalError ("El ID: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no son compatibles.");
                       }					
	      	            			Value resultado=new Value(Integer.parseInt(num.getLexema()));
                            		
					      			TemporalFactoryIF tF = new TemporalFactory(scope);
                            
					      			IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
					      			int dimArray =tipoArray.getValFin()-tipoArray.getValIni()+1;
					      			
					      			TemporalIF temp = tF.create();
					      			OperandIF tempE = exp.getResultado();
					      			TemporalIF tempIE = tF.create();
					      		
					      			Variable var = new Variable(id.getLexema(), scope);
                                    var.setAmbito(tipoArray.getScope());
                                    var.setSize(dimArray);
                                    var.setDesplazamiento(despl);
                                    List code1 = exp.getIntermediateCode();
                                    cb.addQuadruples (code1);
					      			
					      			cb.addQuadruple ("VALOR_VECTOR",var,num.getLexema());
					      						      			
					      			exp.setResultado(temp);
					      			
					      			exp.setIntermediateCode(cb.create());
							  semanticErrorManager.semanticDebug(exp.getIntermediateCode());
                                RESULT=exp;	
                              }								
                            :};//v(1)


// -------------
// Definiciones
// -------------
//tipoPrimitivo::= ENTERO | tipoBooleano;
tipoBooleano::= TRUE:id {: RESULT=id; :} | FALSE:id {: RESULT=id; :};
vacio::=;
tipos::= INTEGER:t {: RESULT="INTEGER"; :} | BOOLEAN:t {: RESULT="BOOLEAN"; :} | ID:id {: RESULT=id.getLexema();:};


// ----------------------------                     
// Definicion de PARAMETROS
// ---------------------------- 
modo::= OUT:t {: RESULT=t; :} | vacio;

// --------------------
// CUERPO programa
// --------------------
cuerpo::= BEGIN listaSentencias:bloque END ID PUNTOYCOMA
{:
    RESULT=bloque;
:};
cuerpo::= BEGIN 
{:
 	// Desplazamiento principal
	desplScope.put(scopeManager.getCurrentScope().getName(), new Integer(despl));
	BloqueSentencias bloque = new BloqueSentencias();
    IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
	cb.addQuadruple ("NOP", null);
	List code=cb.create ();
	bloque.setIntermediateCode (code); 
	RESULT=bloque;
:}
END ID PUNTOYCOMA;



// *****************
// *****************
// *****************
lista_argumentos::= ID:idPar COMA lista_argumentos:listaArg 	{:
                               // Añadir IDs a lista objetos Parametro
                                ListaObjetos lista = new ListaObjetos(listaArg);
                                Parametro par = new Parametro(idPar.getLexema(), 0, idPar.getLine(), idPar.getColumn(),null);
								lista.add(par);
	                        RESULT = lista;
                                :}
			        | ID:idPar {:
				// Añadir ID a lista objetos Variables
				ListaObjetos lista = new ListaObjetos();
				Parametro par = new Parametro(idPar.getLexema(), 0, idPar.getLine(), idPar.getColumn(),null);
				lista.add(par);
	                        RESULT = lista;
				:};
decVariable::=ID:idPar DOSPUNTOS{:
				// Añadir ID a lista objetos Variables
				ListaObjetos lista = new ListaObjetos();
				Var var= new Var (idPar.getLexema(), 0, idPar.getLine(), idPar.getColumn());
				lista.add(var);
	                        RESULT = lista;
				:} | ID:idPar COMA decVariable:listaArg 	{:
                               // Añadir IDs a lista objetos Parametro
                                ListaObjetos lista = new ListaObjetos(listaArg);
                               Var var= new Var (idPar.getLexema(), 0, idPar.getLine(), idPar.getColumn());
							lista.add(var);
	                        RESULT = lista;
				
                                :};
				

lista_parametros::= lista_argumentos:listaArg DOSPUNTOS modo tipos:tp {: 
                            ListaObjetos lista = new ListaObjetos(listaArg);
                            for (int i=0;i<lista.size();i++){
                                Parametro p = (Parametro) lista.get(i);
                                p.setTipo(scopeManager.searchType(tp.toString()));
                            }
                            RESULT=listaArg;
                            :}
                            | lista_argumentos:listaArg1 DOSPUNTOS modo tipos:tp PUNTOYCOMA lista_parametros:listaArg2 {:
        					ListaObjetos lista1 = new ListaObjetos(listaArg1);
                        	for (int i=0;i<lista1.size();i++){
				    			Parametro p = (Parametro) lista1.get(i);
				    			p.setTipo(scopeManager.searchType(tp.toString()));
							}

							ListaObjetos lista2 = new ListaObjetos(listaArg2);
							for (int i=0;i<lista2.size();i++){
								lista1.add(lista2.get(i));
			    			}
							RESULT=lista1;	
                            :};
