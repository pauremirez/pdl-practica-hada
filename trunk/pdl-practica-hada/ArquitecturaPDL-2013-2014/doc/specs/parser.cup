package compiler.syntax;

//-----------------------------
// Declaracion de importaciones 
//-----------------------------
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

//-----------------------------------
// Declaracion del codigo de usuario
//-----------------------------------

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	//FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	// Cadenas 
	List cadenas = new ArrayList();
	// Desplazamiento con RA principal
	int despl=5;

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
		Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

//------------------------------------
// Declaracion de terminales (Ejemplo)
//------------------------------------
terminal Token MAS;
terminal Token ARRAY;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FUNCTION;
terminal Token IF;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OF;
terminal Token OR;
terminal Token OUT;
terminal Token PROCEDURE;
terminal Token PUTLINE;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
terminal Token WHILE;
terminal Token COMILLASDOBLES;
terminal Token PARENTESISIZQ;
terminal Token PARENTESISDER;
terminal Token INICIOCOMENTARIO;
terminal Token SALTOLINEA;
terminal Token COMA;
terminal Token PUNTOYCOMA;
terminal Token DOSPUNTOS;
terminal Token MENOS;
terminal Token MENORQUE;
terminal Token MAYORQUE;
terminal Token IGUALQUE;
terminal Token DISTINTOQUE;
terminal Token AND;
terminal Token ASIGNACION;
terminal Token PUNTO;
terminal Token ID; //Identificador
terminal Token ENTERO;
terminal Token PUNTOPUNTO;
terminal Token CARACTERESCADENA;

//-----------------------------
// Declaracion de no terminales
//-----------------------------
// no modificar los propuestos

non terminal Axiom				axiom;
non terminal					program;
non terminal  					seccionTipos;
non terminal  					seccionVariables;
non terminal  					seccionSubProgramas;
non terminal 					seccionConstantesSimbolicas;
non terminal  					declaracionConstanteSimbolica;
non terminal  					declaracionTipo;
non terminal  					declaracionVariable;
non terminal  					declaracionSubPrograma;
non terminal BloqueSentencias	funcion;
non terminal  					procedimiento;
non terminal ListaObjetos		parametros;
non terminal ListaObjetos		lista_argumentos;
non terminal ListaObjetos		lista_parametros;
non terminal ListaObjetos		idParametros; 
non terminal BloqueSentencias	listaSentencias;
non terminal  					sentencia;
non terminal  					sentenciaProcedimiento;
non terminal BloqueSentencias 	sentenciaPutLine;
non terminal  					sentenciaWhile;
non terminal  					sentenciaIf;
non terminal  					sentenciaAsignacion;
non terminal  					idTipos;
non terminal Expresion			expresion;
non terminal Token				tipoBooleano;
non terminal  					vacio;
non terminal					cuerpoFuncion;
non terminal					cabecera;
non terminal BloqueSentencias	cuerpo;
non terminal Expresion			sentenciaFuncion;
non terminal					lista_parametros_llamada;
non terminal					tipos;
non terminal ListaObjetos		parametro;
non terminal					modo;
non terminal					parametroPutLine;
non terminal					cadenaCaracteres;
non terminal Expresion			vector;
non terminal					procedure;

//-----------------------------------------
// Declaracion de relaciones de precedencia
//-----------------------------------------
precedence left MAS, MENOS;
precedence nonassoc ASIGNACION;
precedence left MENORQUE, MAYORQUE, DISTINTOQUE, IGUALQUE;
precedence left AND, OR;
precedence left PARENTESISIZQ, PARENTESISDER, PUNTO;
precedence right ELSE; 

//------------------------------------
// Declaracion de reglas de produccion
//-------------------------------------

start with program;

program::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden anadir mas acciones semanticas
  		// Comentar estas lineas para el 1er cuatrimestre
  		//List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

// ----------------------
// Inicio programa
// ----------------------
axiom::= procedure PARENTESISIZQ PARENTESISDER IS cabecera cuerpo | procedure PARENTESISIZQ PARENTESISDER IS cuerpo;
axiom::= procedure error PARENTESISIZQ PARENTESISDER IS cabecera cuerpo {:syntaxErrorManager.syntaxFatalError("001. No se ha especificado nombre del progama");:} |
		ID error PARENTESISIZQ PARENTESISDER IS cabecera cuerpo {:syntaxErrorManager.syntaxFatalError("003. Palabra PROCEDURE no definida");:};

procedure::=PROCEDURE ID:id 
{:
	String name=id.getLexema();
	scopeManager.openScope(name);
	
	//Insertar todos los TypesSimple en la TT
	ScopeIF scope = scopeManager.getCurrentScope();
	TypeTableIF tableTypes =scope.getTypeTable();
	TypeInteger typeInteger = new TypeInteger(scope);
	TypeBoolean typeBoolean = new TypeBoolean(scope);
	tableTypes.addType(typeInteger);
	tableTypes.addType(typeBoolean);
:};
procedure::= PROCEDURE error  {:syntaxErrorManager.syntaxFatalError("002. Error en el nombre del programa");:};

cabecera::= seccionConstantesSimbolicas seccionTipos seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionTipos seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionTipos seccionVariables |
			seccionConstantesSimbolicas seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionVariables |
			seccionConstantesSimbolicas |
			seccionTipos seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionTipos seccionVariables |
			seccionTipos seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionTipos |
			seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :}|
			seccionVariables |
			seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :};

seccionConstantesSimbolicas::= declaracionConstanteSimbolica | seccionConstantesSimbolicas declaracionConstanteSimbolica ;
seccionTipos::= declaracionTipo | seccionTipos declaracionTipo;
seccionVariables::= declaracionVariable | seccionVariables declaracionVariable;
seccionSubProgramas::= declaracionSubPrograma | seccionSubProgramas declaracionSubPrograma;


// --------------------
// Seccion Constantes
// -------------------
declaracionConstanteSimbolica::= ID:id DOSPUNTOS CONSTANT ASIGNACION ENTERO:value PUNTOYCOMA
{:
	String name=id.getLexema();
	SymbolTableIF sTable=scopeManager.getCurrentScope().getSymbolTable();
	
	//si la cte está declarada en el ambito --> error: ya ha sido declarada
	//si no --> declararla	
	if(sTable.containsSymbol(name)){
		semanticErrorManager.semanticFatalError("La CONSTANTE "+name+" en la linea "+id.getLine()+" ya ha sido declarada");
	}else{
		SymbolConstant sc= new SymbolConstant (scopeManager.getCurrentScope(),name,scopeManager.searchType("INTEGER"));
		sTable.addSymbol(name,sc);
		sc.setValue(Integer.parseInt(value.getLexema()));
	}
:};
declaracionConstanteSimbolica::= ID:id DOSPUNTOS CONSTANT ASIGNACION tipoBooleano:valor PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si la cte está declarada en el ambito --> error: ya ha sido declarada
	//si no --> declararla	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("La CONSTANTE "+name+" en la linea "+id.getLine()+" ya ha sido declarada");
	}else{
		SymbolTableIF tableSymbol=scope.getSymbolTable();
		SymbolConstant constantSymbol=new SymbolConstant(scope,name, scopeManager.searchType("BOOLEAN"));
		if (valor.getLexema().equalsIgnoreCase("TRUE")) 
			constantSymbol.setValue(1);
		else 
			constantSymbol.setValue(0);
		tableSymbol.addSymbol(name,constantSymbol);
	}
:};

// --------------------
// Seccion TIPOS
// --------------------
declaracionTipo::= TYPE ID:id IS ARRAY PARENTESISIZQ ENTERO:value1 PUNTOPUNTO ENTERO:value2 PARENTESISDER OF INTEGER PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si el tipo está declarado en el ambito --> error: ya ha sido declarado
	//si no --> declararlo	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("El TIPO "+name+" en la linea "+id.getLine()+" y columna "+id.getColumn()+" ya ha sido declarado");
	}else{
		TypeTableIF tableType=scope.getTypeTable();
		TypeSet typeSet =new TypeSet (scope, name);
		typeSet.setValIni (Integer.parseInt(value1.getLexema()));
		typeSet.setValFin (Integer.parseInt(value2.getLexema()));
		tableType.addType(name,typeSet);
	}
:};
declaracionTipo::= TYPE ID:id IS ARRAY PARENTESISIZQ ENTERO:value1 PUNTOPUNTO ENTERO:value2 PARENTESISDER OF BOOLEAN PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si el tipo está declarado en el ambito --> error: ya ha sido declarado
	//si no --> declararlo	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("El TIPO "+name+" en la linea "+id.getLine()+" y columna "+id.getColumn()+" ya ha sido declarado");
	}else{
		TypeTableIF tableType=scope.getTypeTable();
		TypeSet typeSet =new TypeSet (scope, name);
		typeSet.setValIni (Integer.parseInt(value1.getLexema()));
		typeSet.setValFin (Integer.parseInt(value2.getLexema()));
		tableType.addType(name,typeSet);
	}
:};
declaracionTipo::= TYPE ID:id IS ARRAY PARENTESISIZQ ENTERO:value1 PUNTOPUNTO ENTERO:value2 PARENTESISDER OF ID:typeId PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si el tipo está declarado en el ambito --> error: ya ha sido declarado
	//si no --> declararlo	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("El TIPO "+name+" en la linea "+id.getLine()+" y columna "+id.getColumn()+" ya ha sido declarado");
	}else{
		TypeTableIF tableType=scope.getTypeTable();
		TypeSet typeSet =new TypeSet (scope, name);
		typeSet.setValIni (Integer.parseInt(value1.getLexema()));
		typeSet.setValFin (Integer.parseInt(value2.getLexema()));
		tableType.addType(name,typeSet);
		TypeIF typeVar=scopeManager.searchType(typeId.getLexema());
		if(!(typeVar instanceof TypeRecord) && !(typeVar instanceof TypeSet)){
			semanticErrorManager.semanticFatalError("El TIPO "+name+" en la linea "+id.getLine()+" y columna "+id.getColumn()+" no es del tipo RECORD/SET");
		}
	}
:};

// --------------------
// Seccion VARIABLES
// --------------------

declaracionVariable::= idParametros:list INTEGER PUNTOYCOMA
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF tableSymbol=scope.getSymbolTable();

	//Añadir el tipo de variable a la lista
	ListaObjetos var=new ListaObjetos(list);
	for(int i=var.size()-1; i>=0;i--){
		Var v=(Var)var.get(i);
		//Comprobar que no esté definido el mismo ámbito
		if(!scope.getSymbolTable().containsSymbol(v.getName())){
			SymbolVariable symbolVariable=new SymbolVariable(scope, v.getName(), scopeManager.searchType("INTEGER"));
			tableSymbol.addSymbol(v.getName(),symbolVariable);
		}else{
			semanticErrorManager.semanticFatalError("La variable "+v.getName()+" en la linea "+v.getLine()+" y columna "+v.getColumn()+" ya ha sido declarada");
		}
	}
:};
declaracionVariable::= idParametros:list BOOLEAN PUNTOYCOMA
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF tableSymbol=scope.getSymbolTable();
	
	//Añadir el tipo de variable a la lista
	ListaObjetos var=new ListaObjetos(list);
	for(int i=var.size()-1; i>=0;i--){
		Var v=(Var)var.get(i);
		//Comprobar que no esté definido el mismo ámbito
		if(!scope.getSymbolTable().containsSymbol(v.getName())){
			SymbolVariable symbolVariable=new SymbolVariable(scope, v.getName(), scopeManager.searchType("BOOLEAN"));
			tableSymbol.addSymbol(v.getName(),symbolVariable);
		}else{
			semanticErrorManager.semanticFatalError("La variable "+v.getName()+" en la linea "+v.getLine()+" y columna "+v.getColumn()+" ya ha sido declarada");
		}
	}
:};
declaracionVariable::= idParametros:list ID:type PUNTOYCOMA
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF tableSymbol=scope.getSymbolTable();
	TypeTableIF tableType=scope.getTypeTable();

	//Añadir el tipo de variable a la lista
	ListaObjetos var=new ListaObjetos(list);
	for(int i=var.size()-1; i>=0;i--){
		Var v=(Var)var.get(i);
		//Comprobar que no esté definido el mismo ámbito
		if(!scope.getSymbolTable().containsSymbol(v.getName())){
			SymbolVariable symbolVariable=new SymbolVariable(scope, v.getName(), scopeManager.searchType("INTEGER"));
			tableSymbol.addSymbol(v.getName(),symbolVariable);
			if(tableType.getType(type.getLexema()) instanceof TypeRecord){
				TypeRecord typeRecord = (TypeRecord) symbolVariable.getType();
			}
		}else{
			semanticErrorManager.semanticFatalError("La variable "+v.getName()+" en la linea "+v.getLine()+" y columna "+v.getColumn()+" ya ha sido declarada");
		}
	}
	if(!scopeManager.containsType(type.getLexema())){
		semanticErrorManager.semanticFatalError("La variable "+type.getLexema()+" en la linea "+type.getLine()+" y columna "+type.getColumn()+" no ha sido declarada");
	}else{
		TypeIF typeIf=scopeManager.searchType(type.getLexema());
		if(!(typeIf instanceof TypeRecord) && !(typeIf instanceof TypeSet)){
			semanticErrorManager.semanticFatalError("La variable "+type.getLexema()+" en la linea "+type.getLine()+" y columna "+type.getColumn()+" no es del tipo RECORD/SET");
		}
	}	
:};
// --------------------
// Seccion SUBPROGRAMAS
// --------------------
declaracionSubPrograma::= procedimiento | funcion;

// ------------------------                     
// Definicion de FUNCION 
// ------------------------  
funcion::= FUNCTION ID:id PARENTESISIZQ lista_parametros:param PARENTESISDER RETURN tipos:type IS cabecera:cabFun cuerpoFuncion:cuerpFun;
funcion::= FUNCTION ID:id PARENTESISIZQ PARENTESISDER RETURN tipos:type IS cabecera:cabFun cuerpoFuncion:cuerpFun; 
funcion::= FUNCTION ID:id PARENTESISIZQ lista_parametros:param PARENTESISDER RETURN tipos:t IS cuerpoFuncion:cuerpo;
funcion::= FUNCTION ID:id PARENTESISIZQ PARENTESISDER RETURN tipos:type IS  cuerpoFuncion:cuerpFun; 
funcion::= FUNCTION ID error RETURN tipos IS cuerpoFuncion {:syntaxErrorManager.syntaxFatalError("001. Faltan los DOS PARENTESIS");:};
			
cuerpoFuncion::= BEGIN listaSentencias RETURN expresion PUNTOYCOMA END ID PUNTOYCOMA |
				BEGIN RETURN expresion PUNTOYCOMA END ID PUNTOYCOMA;

// ----------------------------                     
// Definicion de PROCEDIMIENTO
// ----------------------------  
procedimiento::= procedure PARENTESISIZQ parametros PARENTESISDER IS cabecera cuerpo |
				procedure PARENTESISIZQ parametros PARENTESISDER IS cuerpo;

// ----------------------------                     
// Definicion de SENTENCIAS		
// ---------------------------- 
listaSentencias::= sentencia:sent {:
                                RESULT=sent;
					:}  | listaSentencias:blq sentencia:sent{:
					BloqueSentencias bloque = new BloqueSentencias();
                                       
					RESULT=bloque;

				    :};

sentencia::=sentenciaAsignacion:sent {: RESULT=sent; :}| 
			sentenciaIf:sent {: RESULT=sent; :} | 
			sentenciaWhile:sent {: RESULT=sent; :} | 
			sentenciaPutLine:sent {: RESULT=sent; :} | 
			sentenciaProcedimiento:sent {: RESULT=sent; :};

// ------------------------
// Sentencia PUTLINE
// ------------------------
sentenciaPutLine::= PUTLINE:id PARENTESISIZQ CARACTERESCADENA:cad PARENTESISDER PUNTOYCOMA
{:
     	semanticErrorManager.semanticInfo ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] es una CADENA DE CARACTERES.");
       
     	BloqueSentencias bloque = new BloqueSentencias();
				ScopeIF scope = scopeManager.getCurrentScope();
				cadenas.add(cad.getLexema());
					RESULT=bloque;		
				:};

sentenciaPutLine::= PUTLINE:id PARENTESISIZQ expresion:exp PARENTESISDER PUNTOYCOMA
{:    
        if ( exp.getTipo().getName().equals("INTEGER") &&  exp.getTipo().getName().equals("POINTER") ) 
            semanticErrorManager.semanticInfo ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] es un ENTERO.");
        if ( exp.getTipo().getName().equals("BOOLEAN") ) 
            semanticErrorManager.semanticInfo ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] es un BOOLEANO.");
                                                        
            BloqueSentencias bloque = new BloqueSentencias();
            ScopeIF scope = scopeManager.getCurrentScope();
			RESULT=bloque;
	   :}; 


//parametroPutLine::= cadenaCaracteres  | expresion;
cadenaCaracteres::= CARACTERESCADENA;
// ------------------------
// Sentencia WHILE
// ------------------------
sentenciaWhile::= WHILE expresion:exp LOOP listaSentencias:sent END LOOP PUNTOYCOMA{:
                              if ( !(exp.getTipo().getName().equals("BOOLEAN")) )
                                    semanticErrorManager.semanticFatalError ("326. La expresion sentencia REPEAT no es BOOLEANA.");
                              BloqueSentencias bloque = new BloqueSentencias();
                              ScopeIF scope = scopeManager.getCurrentScope();
					
                             
                              RESULT=bloque;
                            :};

// ------------------------
// Sentencia IF
// ------------------------
sentenciaIf::= IF expresion THEN listaSentencias END IF PUNTOYCOMA | IF expresion THEN listaSentencias ELSE listaSentencias END IF PUNTOYCOMA;

// ------------------------
// Sentencia ASIGNACION
// ------------------------
sentenciaAsignacion::= idTipos ASIGNACION expresion PUNTOYCOMA;

idTipos::= ID | ID PUNTO ID | ID PUNTO ID PUNTO ID | vector;

vector::= ID PARENTESISIZQ ENTERO PARENTESISDER;

// ------------------------
// Sentencia FUNCION
// ------------------------
sentenciaFuncion ::= ID PARENTESISIZQ lista_parametros_llamada PARENTESISDER PUNTOYCOMA;

lista_parametros_llamada::= expresion | expresion COMA lista_parametros_llamada;

// ------------------------
// Sentencia PROCEDIMIENTO
// ------------------------
sentenciaProcedimiento::= idTipos ASIGNACION ID PARENTESISIZQ lista_parametros_llamada PARENTESISDER PUNTOYCOMA |
						ID PARENTESISIZQ lista_parametros_llamada PARENTESISDER PUNTOYCOMA;

// --------------------
// Expresion 
// --------------------
expresion::=expresion:exp1 MENOS:id expresion:exp2
{:
                            Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                            if (exp.castingTipos(exp1 , exp2) ) {
                                 semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            }else{
                            	ScopeIF scope = scopeManager.getCurrentScope();

			
                                		
				RESULT=exp;
                             }

					:}; 
expresion::= expresion:exp1 MAS:id expresion:exp2
{:
                            ScopeIF scope = scopeManager.getCurrentScope();
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                            Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                          
						 // Suma CONJUNTOS
                            if (exp1.getTipo().equals(exp2.getTipo()) && exp1.getTipo() instanceof TypeSet) {
                                TypeSet tipoSet = (TypeSet) exp1.getTipo();
                                exp.setTipo(exp1.getTipo());
                                
                            // Suma ENTEROS y/o PUNTEROS  
                            } else {
                                if (exp.castingTipos(exp1 , exp2) )
                                     semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + 
                                        id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                                  
                            }
                           
                            RESULT=exp;
                            :} | 
			expresion:exp1 OR:id expresion:exp2 {:
                            if ( !(exp1.getTipo() == exp2.getTipo()) || !(exp1.getTipo().getName().equals("BOOLEAN")) || !(exp2.getTipo().getName().equals("BOOLEAN")) ) {
                                semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + 
						id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            }else{
		      	        Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
				ScopeIF scope = scopeManager.getCurrentScope();
				
                                Value verdad = new Value(1);
                                Value falso = new Value(0);
        			
              
				RESULT=exp;
                            }
        		:}| 
			expresion:exp1 AND:id expresion:exp2 {:
                            if ( !(exp1.getTipo() == exp2.getTipo()) || !(exp1.getTipo().getName().equals("BOOLEAN")) || !(exp2.getTipo().getName().equals("BOOLEAN")) ) {
                                semanticErrorManager.semanticFatalError ("228. La expresion: " + id.getLexema() +" en [" + 
						id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            }else{
		      	        Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
				ScopeIF scope = scopeManager.getCurrentScope();
				

                                Value verdad = new Value(1);
                                Value falso = new Value(0);
        		
				RESULT=exp;
                            }
        		:} | 
			expresion:exp1 MAYORQUE:id expresion:exp2 
{:
			    if ( !(exp1.getTipo() == exp2.getTipo())  ||  !(exp1.getTipo().getName().equals("INTEGER"))  || !(exp2.getTipo().getName().equals("INTEGER")) )  {
                                  semanticErrorManager.semanticFatalError ("230. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			     }else{
		      	          Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
				  ScopeIF scope = scopeManager.getCurrentScope();
				 

                                  Value verdad = new Value(1);
                                  Value falso = new Value(0);
        			  

						
				  RESULT=exp;
				}
					:} | 
			expresion:exp1 MENORQUE:id expresion:exp2 
{:
			    if ( !(exp1.getTipo() == exp2.getTipo())  ||  !(exp1.getTipo().getName().equals("INTEGER"))  || !(exp2.getTipo().getName().equals("INTEGER")) )  {
                                  semanticErrorManager.semanticFatalError ("232. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			     }else{
		      	          Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
				  ScopeIF scope = scopeManager.getCurrentScope();
				 
                                  Value verdad = new Value(1);
                                  Value falso = new Value(0);
        			 
						
				  RESULT=exp;
				}
					:} | 
			expresion:exp1 IGUALQUE:id expresion:exp2 {:
                            if ( !(exp1.getTipo() == exp2.getTipo()) )
                                  semanticErrorManager.semanticFatalError ("234. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            if ( (exp1.getTipo() instanceof TypeRecord) || exp1.getTipo() instanceof TypeSet )
                                  semanticErrorManager.semanticFatalError ("236. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no permitida para este tipo.");
                            
                            Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                            ScopeIF scope = scopeManager.getCurrentScope();
                           
                            
                            
                            Value verdad = new Value(1);
                            Value falso = new Value(0);
                            
                            RESULT=exp;
                  	:} | 
			expresion:exp1 DISTINTOQUE:id expresion:exp2
			{:
                            if ( !(exp1.getTipo() == exp2.getTipo()) )
                                  semanticErrorManager.semanticFatalError ("238. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            if ( (exp1.getTipo() instanceof TypeRecord) || exp1.getTipo() instanceof TypeSet )
                                  semanticErrorManager.semanticFatalError ("240. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no permitida para este tipo.");
                     
                            Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                            ScopeIF scope = scopeManager.getCurrentScope();
                           
                            Value verdad = new Value(1);
                            Value falso = new Value(0);
                           
                            RESULT=exp;
                            :} | 
			PARENTESISIZQ expresion:exp PARENTESISDER {: 
					RESULT=exp; 
                            :};
expresion::= ID:id
{:
ScopeIF scope = scopeManager.getCurrentScope();
			        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
                  		TypeTableIF tablaTipos = scope.getTypeTable();
			        if (!(scopeManager.containsSymbol(id.getLexema()))) {
                                    semanticErrorManager.semanticFatalError ("242. La variable: " + id.getLexema() +" en [" + 
									id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                    		} else {
                                    SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                                    Expresion exp = new Expresion(simbolo.getType(), id.getLine(), id.getColumn());
                                    if (simbolo instanceof SymbolConstant) {
					SymbolConstant simboloCte = (SymbolConstant) simbolo;
					Value valor=new Value(simboloCte.getValue());
                                        exp.setResultado(valor);
				    }else{
                                     
				       
                                    }
                       		    RESULT = exp;
                    		}
                		:};
expresion::= ENTERO:num {:
                            ScopeIF scope = scopeManager.getCurrentScope();
	      	            Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), num.getLine(), num.getColumn());
			    Value resultado=new Value(Integer.parseInt(num.getLexema()));
                            exp.setResultado(resultado);  // Guardamos el valor operador
			    RESULT = exp;
                            :}|
			ID:id PUNTO ID:campo {:
			    if ( !(scopeManager.containsSymbol(id.getLexema())) ) {
                                  semanticErrorManager.semanticFatalError ("244. El tipo registro: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                            }
                            ScopeIF scope = scopeManager.getCurrentScope();
                            SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                            TypeRecord tipoRecord = (TypeRecord) scopeManager.searchType(simbolo.getType().getName());

                            // El campo existe en el Registro
                            if (! tipoRecord.containsCampo(campo.getLexema() )) {
                                    semanticErrorManager.semanticFatalError ("246. El campo registro: " + campo.getLexema() +" en [" + 
							campo.getLine() + ":" + campo.getColumn() + "] no ha sido definida.");
                            }                            
                            Expresion exp = new Expresion(tipoRecord.getTypeCampo(campo.getLexema()), campo.getLine(), campo.getColumn());
                            HashMap tablaCampos = tipoRecord.getTablaCampos();
                            SymbolVariable simboloCampo = (SymbolVariable) tablaCampos.get(campo.getLexema()); 


                            exp.setReferencia(true);


                            RESULT = exp;
                		:}|
			ID PUNTO ID PUNTO ID  |
			sentenciaFuncion:exp {:
                                RESULT=exp;									
                            :} |
			tipoBooleano :id {:
                            ScopeIF scope = scopeManager.getCurrentScope();
	      	            Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                            // Le damos el valor true=1 y false=0
                            Value resultado=new Value(0);
                            if (id.getLexema().equals("TRUE")){
				resultado=new Value(1);
                            }
				exp.setResultado(resultado);
                                RESULT=exp;			:} |
			vector:exp {:
                                RESULT=exp;									
                            :};

// -------------
// Definiciones
// -------------
//tipoPrimitivo::= ENTERO | tipoBooleano;
tipoBooleano::= TRUE:id {: RESULT=id; :} | FALSE:id {: RESULT=id; :};
vacio::=;
tipos::= INTEGER:t {: RESULT="INTEGER"; :} | BOOLEAN:t {: RESULT="BOOLEAN"; :} | ID:id {: RESULT=id.getLexema();:};
idParametros::= ID:id DOSPUNTOS
{:
   // Añadir IDs a lista objetos Variables
	ListaObjetos list = new ListaObjetos();
    Var var = new Var (id.getLexema(), null, id.getLine(), id.getColumn());
    list.add(var);
    RESULT = list;
:};
idParametros::= ID:id COMA idParametros:listParam
{:
   	// Añadir IDs a lista objetos Variables
   	ListaObjetos list = new ListaObjetos(listParam);
   	Var var = new Var (id.getLexema(), 0, id.getLine(), id.getColumn());
   	list.add(var);
	RESULT = list;
:};

// ----------------------------                     
// Definicion de PARAMETROS
// ---------------------------- 
parametros::= parametro | parametro PUNTOYCOMA parametros;
parametro::= idParametros:id modo tipos:t
{:
	syntaxErrorManager.syntaxInfo ("Parametros ID: " + id);
	syntaxErrorManager.syntaxInfo ("Parametros TIPO: " + t);
	
	//SymbolParameter parametro=new SymbolParameter (scopeManager.getCurrentScope(),id.getLexema(),scopeManager.searchType(t.toString()));
	
	ListaObjetos lista = new ListaObjetos(id);
 /*   for (int i=0;i<lista.size();i++){
    	syntaxErrorManager.syntaxInfo ("lista.get(i)"+lista.get(i));
    	Parametro p = (Parametro) lista.get(i);
       	p.setReferencia(true);
		p.setTipo(scopeManager.searchType(t.toString()));
   	}*/
:};

modo::= OUT:t {: RESULT=t; :} | vacio;

// --------------------
// CUERPO programa
// --------------------
cuerpo::= BEGIN listaSentencias:bloque END ID PUNTOYCOMA
{:
    RESULT=bloque;
:};
cuerpo::= BEGIN 
{:
	BloqueSentencias bloque = new BloqueSentencias();
	RESULT=bloque;
:}
END ID PUNTOYCOMA;



// *****************
// *****************
// *****************
lista_argumentos::= ID:idPar COMA lista_argumentos:listaArg 	{:
                               // Añadir IDs a lista objetos Parametro
                                ListaObjetos lista = new ListaObjetos(listaArg);
                                Parametro par = new Parametro(idPar.getLexema(), 0, idPar.getLine(), idPar.getColumn(),null);
				lista.add(par);
	                        RESULT = lista;
                                :}
			        | ID:idPar {:
				// Añadir ID a lista objetos Variables
				ListaObjetos lista = new ListaObjetos();
				Parametro par = new Parametro(idPar.getLexema(), 0, idPar.getLine(), idPar.getColumn(),null);
				lista.add(par);
	                        RESULT = lista;
				:} ;
				

lista_parametros::= lista_argumentos:listaArg DOSPUNTOS modo tipos:tp {: 
                            ListaObjetos lista = new ListaObjetos(listaArg);
                            for (int i=0;i<lista.size();i++){
                                Parametro p = (Parametro) lista.get(i);
                                p.setTipo(scopeManager.searchType(tp.toString()));
                            }
                            RESULT=listaArg;
                            :}
                            | lista_argumentos:listaArg1 DOSPUNTOS modo tipos:tp PUNTOYCOMA lista_parametros:listaArg2 {:
        			ListaObjetos lista1 = new ListaObjetos(listaArg1);
                        	for (int i=0;i<lista1.size();i++){
				    Parametro p = (Parametro) lista1.get(i);
				    p.setTipo(scopeManager.searchType(tp.toString()));
				}

				ListaObjetos lista2 = new ListaObjetos(listaArg2);
				for (int i=0;i<lista2.size();i++){
						lista1.add(lista2.get(i));
    				}
				RESULT=lista1;	
                            :};

