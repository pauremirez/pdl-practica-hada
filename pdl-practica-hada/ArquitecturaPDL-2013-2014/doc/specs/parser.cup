package compiler.syntax;

//-----------------------------
// Declaracion de importaciones 
//-----------------------------
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

//-----------------------------------
// Declaracion del codigo de usuario
//-----------------------------------

action code {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	//FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	// Cadenas 
	List cadenas = new ArrayList();



	// Desplazamiento x ambito
	HashMap desplScope = new HashMap(); 

:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
		Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}

//------------------------------------
// Declaracion de terminales (Ejemplo)
//------------------------------------
terminal Token MAS;
terminal Token ARRAY;
terminal Token BEGIN;
terminal Token BOOLEAN;
terminal Token CONSTANT;
terminal Token ELSE;
terminal Token END;
terminal Token FALSE;
terminal Token FUNCTION;
terminal Token IF;
terminal Token INTEGER;
terminal Token IS;
terminal Token LOOP;
terminal Token OF;
terminal Token OR;
terminal Token OUT;
terminal Token PROCEDURE;
terminal Token PUTLINE;
terminal Token RETURN;
terminal Token THEN;
terminal Token TRUE;
terminal Token TYPE;
terminal Token WHILE;
terminal Token COMILLASDOBLES;
terminal Token PARENTESISIZQ;
terminal Token PARENTESISDER;
terminal Token INICIOCOMENTARIO;
terminal Token SALTOLINEA;
terminal Token COMA;
terminal Token PUNTOYCOMA;
terminal Token DOSPUNTOS;
terminal Token MENOS;
terminal Token MENORQUE;
terminal Token MAYORQUE;
terminal Token IGUALQUE;
terminal Token DISTINTOQUE;
terminal Token AND;
terminal Token ASIGNACION;
terminal Token PUNTO;
terminal Token ID; //Identificador
terminal Token ENTERO;
terminal Token PUNTOPUNTO;
terminal Token CARACTERESCADENA;

//-----------------------------
// Declaracion de no terminales
//-----------------------------
// no modificar los propuestos

non terminal Axiom				axiom;
non terminal					program;
non terminal  					seccionTipos;
non terminal  					seccionVariables;
non terminal BloqueSentencias	seccionSubProgramas;
non terminal BloqueSentencias	seccionConstantesSimbolicas;
non terminal BloqueSentencias	declaracionConstanteSimbolica;
non terminal  					declaracionTipo;
non terminal  					declaracionVariable;
non terminal BloqueSentencias	declaracionSubPrograma;
non terminal BloqueSentencias	funcion;
non terminal BloqueSentencias	procedimiento;
non terminal ListaObjetos		parametros;
non terminal ListaObjetos		lista_argumentos;
non terminal ListaObjetos		lista_parametros;
non terminal ListaObjetos		decVariable; 
non terminal BloqueSentencias	listaSentencias;
non terminal BloqueSentencias	sentencia;
non terminal BloqueSentencias	sentenciaProcedimiento;
non terminal BloqueSentencias 	sentenciaPutLine;
non terminal BloqueSentencias	sentenciaWhile;
non terminal BloqueSentencias	sentenciaIf;
non terminal BloqueSentencias	sentenciaAsignacion;
non terminal BloqueSentencias	idTipos;
non terminal Expresion			expresion;
non terminal Token				tipoBooleano;
non terminal  					vacio;
non terminal BloqueSentencias	cuerpoFuncion;
non terminal BloqueSentencias	cabecera;
non terminal BloqueSentencias	cuerpo;
non terminal Expresion			sentenciaFuncion;
non terminal ListaObjetos 		lista_parametros_llamada;
non terminal					tipos;
non terminal ListaObjetos		parametro;
non terminal					modo;
non terminal BloqueSentencias	procedure;

//-----------------------------------------
// Declaracion de relaciones de precedencia
//-----------------------------------------
precedence left MAS, MENOS;
precedence nonassoc ASIGNACION;
precedence left MENORQUE, MAYORQUE, DISTINTOQUE, IGUALQUE;
precedence left AND, OR;
precedence left PARENTESISIZQ, PARENTESISDER, PUNTO;
precedence right ELSE; 

//------------------------------------
// Declaracion de reglas de produccion
//-------------------------------------

start with program;

program::= 
  {: 
        syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
   :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden anadir mas acciones semanticas
  		// Comentar estas lineas para el 1er cuatrimestre

		
		//Asignar direcciones de memoria
		MemoryManager.assignAddresses();
		
		IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
		cb.addQuadruple ("INICIO",MemoryManager.getgAddress(),ax.getMainLabel());
		

  		List intermediateCode = ax.getIntermediateCode ();
  		//finalCodeFactory.create (intermediateCode);

  		
  		cb.addQuadruples (intermediateCode);
  		cb.addQuadruple ("FINAL");
  		
  		//finalCodeFactory.create (intermediateCode);
  		  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
   :};

// ----------------------
// Inicio programa
// ----------------------


axiom::= procedure PARENTESISIZQ PARENTESISDER IS cabecera:cab cuerpo:bloque {:
                            // Tabla de nullazamientos para el CF
                            ScopeIF scope = scopeManager.getCurrentScope();
                          
							Axiom ax = new Axiom();
                            RESULT=ax;

				
			:} | procedure PARENTESISIZQ PARENTESISDER IS cuerpo:bloque {:
                            // Tabla de desplazamientos para el CF
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
							Axiom ax = new Axiom();
										
                            RESULT=ax;
				
			:} ;



axiom::= procedure error PARENTESISIZQ PARENTESISDER IS cabecera cuerpo {:syntaxErrorManager.syntaxFatalError("001. No se ha especificado nombre del progama");:} |
		ID error PARENTESISIZQ PARENTESISDER IS cabecera cuerpo {:syntaxErrorManager.syntaxFatalError("003. Palabra PROCEDURE no definida");:};

procedure::=PROCEDURE ID:id 
{:
	String name=id.getLexema();
	scopeManager.openScope(name);
	
	//Insertar todos los TypesSimple en la TT
	ScopeIF scope = scopeManager.getCurrentScope();
	TypeTableIF tableTypes =scope.getTypeTable();
	TypeInteger typeInteger = new TypeInteger(scope);
	TypeBoolean typeBoolean = new TypeBoolean(scope);
	TypeArray typeArray = new TypeArray(scope);
	tableTypes.addType(typeInteger);
	tableTypes.addType(typeBoolean);
	tableTypes.addType(typeArray);
:};
procedure::= PROCEDURE error  {:syntaxErrorManager.syntaxFatalError("002. Error en el nombre del programa");:};

cabecera::= seccionConstantesSimbolicas seccionTipos seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionTipos seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionTipos seccionVariables {:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionConstantesSimbolicas seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionConstantesSimbolicas seccionVariables {:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionConstantesSimbolicas{:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionTipos seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionTipos seccionVariables {:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionTipos seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :} |
			seccionTipos {:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionVariables seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :}|
			seccionVariables {:
								BloqueSentencias bloque=new BloqueSentencias();
                                RESULT=bloque; 
                            :}|
			seccionSubProgramas:bloque{:
                                RESULT=bloque; 
                            :};

seccionConstantesSimbolicas::= declaracionConstanteSimbolica | seccionConstantesSimbolicas declaracionConstanteSimbolica ;
seccionTipos::= declaracionTipo | seccionTipos declaracionTipo;
seccionVariables::= declaracionVariable | seccionVariables declaracionVariable;
seccionSubProgramas::= declaracionSubPrograma | seccionSubProgramas declaracionSubPrograma;


// --------------------
// Seccion Constantes
// -------------------
declaracionConstanteSimbolica::= ID:id DOSPUNTOS CONSTANT ASIGNACION ENTERO:value PUNTOYCOMA
{:
	String name=id.getLexema();
	SymbolTableIF sTable=scopeManager.getCurrentScope().getSymbolTable();
	
	//si la cte está declarada en el ambito --> error: ya ha sido declarada
	//si no --> declararla	
	if(sTable.containsSymbol(name)){
		semanticErrorManager.semanticFatalError("La CONSTANTE "+name+" en la linea "+id.getLine()+" ya ha sido declarada");
	}else{
		SymbolConstant sc= new SymbolConstant (scopeManager.getCurrentScope(),name,scopeManager.searchType("INTEGER"));
		sTable.addSymbol(name,sc);
		sc.setValue(Integer.parseInt(value.getLexema()));
	}
:};
declaracionConstanteSimbolica::= ID:id DOSPUNTOS CONSTANT ASIGNACION tipoBooleano:valor PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si la cte está declarada en el ambito --> error: ya ha sido declarada
	//si no --> declararla	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("La CONSTANTE "+name+" en la linea "+id.getLine()+" ya ha sido declarada");
	}else{
		SymbolTableIF tableSymbol=scope.getSymbolTable();
		SymbolConstant constantSymbol=new SymbolConstant(scope,name, scopeManager.searchType("BOOLEAN"));
		if (valor.getLexema().equalsIgnoreCase("true")) 
			constantSymbol.setValue(1);
		else 
			constantSymbol.setValue(0);
		tableSymbol.addSymbol(name,constantSymbol);
	}
:};

// --------------------
// Seccion TIPOS
// --------------------
declaracionTipo::= TYPE ID:id IS ARRAY PARENTESISIZQ ENTERO:value1 PUNTOPUNTO ENTERO:value2 PARENTESISDER OF INTEGER PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si el tipo está declarado en el ambito --> error: ya ha sido declarado
	//si no --> declararlo	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("El TIPO "+name+" en la linea "+id.getLine()+" y columna "+id.getColumn()+" ya ha sido declarado");
	}else{
		TypeTableIF tableType=scope.getTypeTable();
		TypeArray typeArray =new TypeArray (scope, name);
		typeArray.setValIni (Integer.parseInt(value1.getLexema()));
		typeArray.setValFin (Integer.parseInt(value2.getLexema()));
		typeArray.setTipo (scopeManager.searchType("INTEGER"));
		tableType.addType(name,typeArray);
	}
:};
declaracionTipo::= TYPE ID:id IS ARRAY PARENTESISIZQ ENTERO:value1 PUNTOPUNTO ENTERO:value2 PARENTESISDER OF BOOLEAN PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si el tipo está declarado en el ambito --> error: ya ha sido declarado
	//si no --> declararlo	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("El TIPO "+name+" en la linea "+id.getLine()+" y columna "+id.getColumn()+" ya ha sido declarado");
	}else{
		TypeTableIF tableType=scope.getTypeTable();
		TypeArray typeArray =new TypeArray (scope, name);
		typeArray.setValIni (Integer.parseInt(value1.getLexema()));
		typeArray.setValFin (Integer.parseInt(value2.getLexema()));
		typeArray.setTipo (scopeManager.searchType("BOOLEAN"));
		tableType.addType(name,typeArray);
	}
:};
declaracionTipo::= TYPE ID:id IS ARRAY PARENTESISIZQ ENTERO:value1 PUNTOPUNTO ENTERO:value2 PARENTESISDER OF ID:typeId PUNTOYCOMA
{:
	String name=id.getLexema();
	ScopeIF scope = scopeManager.getCurrentScope();

	//si el tipo está declarado en el ambito --> error: ya ha sido declarado
	//si no --> declararlo	
	if(scope.getSymbolTable().containsSymbol(name)){
		semanticErrorManager.semanticFatalError("El TIPO "+name+" en la linea "+id.getLine()+" y columna "+id.getColumn()+" ya ha sido declarado");
	}else{
		TypeTableIF tableType=scope.getTypeTable();
		TypeArray typeArray =new TypeArray (scope, name);
		typeArray.setValIni (Integer.parseInt(value1.getLexema()));
		typeArray.setValFin (Integer.parseInt(value2.getLexema()));
		typeArray.setTipo (scopeManager.searchType(typeId.getLexema()));
		tableType.addType(name,typeArray);
		TypeIF typeVar=scopeManager.searchType(typeId.getLexema());
		if(!(typeVar instanceof TypeRecord) && !(typeVar instanceof TypeArray)){
			semanticErrorManager.semanticFatalError("El TIPO "+name+" en la linea "+id.getLine()+" y columna "+id.getColumn()+" no es del tipo RECORD/ARRAY");
		}
	}
:};

// --------------------
// Seccion VARIABLES
// --------------------

declaracionVariable::= decVariable:list INTEGER PUNTOYCOMA
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF tableSymbol=scope.getSymbolTable();

	//Añadir el tipo de variable a la lista
	ListaObjetos var=new ListaObjetos(list);
	for(int i=var.size()-1; i>=0;i--){
		Var v=(Var)var.get(i);
		//Comprobar que no esté definido el mismo ámbito
		if(!scope.getSymbolTable().containsSymbol(v.getName())){
			SymbolVariable symbolVariable=new SymbolVariable(scope, v.getName(), scopeManager.searchType("INTEGER"));
			tableSymbol.addSymbol(v.getName(),symbolVariable);
		}else{
			semanticErrorManager.semanticFatalError("La variable "+v.getName()+" en la linea "+v.getLine()+" y columna "+v.getColumn()+" ya ha sido declarada");
		}
	}
:};
declaracionVariable::= decVariable:list BOOLEAN PUNTOYCOMA
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF tableSymbol=scope.getSymbolTable();
	
	//Añadir el tipo de variable a la lista
	ListaObjetos var=new ListaObjetos(list);
	for(int i=var.size()-1; i>=0;i--){
		Var v=(Var)var.get(i);
		//Comprobar que no esté definido el mismo ámbito
		if(!scope.getSymbolTable().containsSymbol(v.getName())){
			SymbolVariable symbolVariable=new SymbolVariable(scope, v.getName(), scopeManager.searchType("BOOLEAN"));
			tableSymbol.addSymbol(v.getName(),symbolVariable);
		}else{
			semanticErrorManager.semanticFatalError("La variable "+v.getName()+" en la linea "+v.getLine()+" y columna "+v.getColumn()+" ya ha sido declarada");
		}
	}
:};
declaracionVariable::= decVariable:list ID:type PUNTOYCOMA
{:
	ScopeIF scope = scopeManager.getCurrentScope();
	SymbolTableIF tableSymbol=scope.getSymbolTable();
	TypeTableIF tableType=scope.getTypeTable();

	//Añadir el tipo de variable a la lista
	ListaObjetos var=new ListaObjetos(list);
	
	semanticErrorManager.semanticInfo("Lista variables: "+var.size());
	
	for(int i=var.size()-1; i>=0;i--){
		Var v=(Var)var.get(i);
		//Comprobar que no esté definido el mismo ámbito
		if(!scope.getSymbolTable().containsSymbol(v.getName())){
			SymbolVariable symbolVariable=new SymbolVariable(scope, v.getName(),scopeManager.searchType(type.getLexema()));
			tableSymbol.addSymbol(v.getName(),symbolVariable);
			if(tableType.getType(type.getLexema()) instanceof TypeArray){
				TypeArray typeArray = (TypeArray) symbolVariable.getType();
			}
		}else{
			semanticErrorManager.semanticFatalError("La variable "+v.getName()+" en la linea "+v.getLine()+" y columna "+v.getColumn()+" ya ha sido declarada");
		}
	}
	if(!scopeManager.containsType(type.getLexema())){
		semanticErrorManager.semanticFatalError("La variable "+type.getLexema()+" en la linea "+type.getLine()+" y columna "+type.getColumn()+" no ha sido declarada");
	}else{
		TypeIF typeIf=scopeManager.searchType(type.getLexema());
		if( !(typeIf instanceof TypeArray)){
			semanticErrorManager.semanticFatalError("La variable "+type.getLexema()+" en la linea "+type.getLine()+" y columna "+type.getColumn()+" no es del tipo RECORD/ARRAY");
		}
	}	
:};
// --------------------
// Seccion SUBPROGRAMAS
// --------------------
declaracionSubPrograma::= procedimiento:bloque {: RESULT=bloque; :}| funcion:bloque {: RESULT=bloque; :};

// ------------------------                     
// Definicion de FUNCION 
// ------------------------  
funcion::= FUNCTION ID:idFunc PARENTESISIZQ lista_parametros:listaArg PARENTESISDER RETURN tipos:tp IS 
{:
			semanticErrorManager.semanticInfo("FUNCION: "+idFunc.getLexema()+" en la linea: "+idFunc.getLine());
 				// la funcion ha sido declarada
                            if (scopeManager.containsSymbol(idFunc.getLexema())) {
				semanticErrorManager.semanticFatalError("350. La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" ya ha sido declarada");
                            }else{ 
                                
				// Crear FUNCION en ambito
				ScopeIF scope = scopeManager.getCurrentScope();
                                TypeTableIF tablaTipos = scope.getTypeTable();
	  			SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
                                // a�adir funcion a TT
                               	TypeFunction tipoFuncion = new TypeFunction(scope, idFunc.getLexema());
				tablaTipos.addType(idFunc.getLexema(), tipoFuncion);
							
				// a�adir funcion a TS
                                SymbolFunction simboloFunc = new SymbolFunction(scope,idFunc.getLexema(),tablaTipos.getType(idFunc.getLexema()));
				tablaSimbolos.addSymbol(idFunc.getLexema(), simboloFunc);
							
				// NUEVO ambito para funcion y tabla TS y TT
				scopeManager.openScope(idFunc.getLexema()); 
                                
														
				tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

                                // Grabo tipo retorno
				tipoFuncion.setTipoRetorno(scopeManager.searchType(tp.toString()));

				// Grabo parametros funcion
                                // ListaObjetos parametros = new ListaObjetos(listaArg) 
				ArrayList parametros = new ArrayList(Utilidades.ordenaParametros(listaArg));
                                
        			for (int i=0; i<parametros.size(); i++){
                                    Parametro p = (Parametro) parametros.get(i);
                                    SymbolVariable simboloVar = new SymbolVariable (scopeManager.getCurrentScope(), p.getNombre(), p.getTipo());
                                    
                                    // Creo lista ordenada de parametros en el PROCEDIMIENTO.
                                    tipoFuncion.setTypeParametro(p.getColumna(),p.getTipo()); 
                                    // Fijar paso parametros Ref/Valor en Symbolvar
                                    simboloVar.setReferencia(p.getReferencia());
                                    tablaSimbolos.addSymbol(p.getNombre(),simboloVar);                                  	
                                    tipoFuncion.setParametro(simboloVar);
                                } 
       
                                tipoFuncion.setHayRetorno(true);
                               
                                
                              }
:} 
cabecera:bloque1 cuerpoFuncion:bloque2 {:
                                BloqueSentencias bloque = new BloqueSentencias();
                               
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeFunction tipoFuncion = (TypeFunction) scopeManager.searchType(scope.getName());
                                

                                // Cerramos Scope
                               scopeManager.closeScope();

                                // Comprobar que hay return de la funcion

                                if  (! tipoFuncion.getHayRetorno())
                                    semanticErrorManager.semanticFatalError("352. La funcion "+tipoFuncion.getName()+" no tiene retorno"); 
                                RESULT=bloque;
              
:};
funcion::= FUNCTION ID:idFunc PARENTESISIZQ PARENTESISDER RETURN tipos:tp IS 
{:
			semanticErrorManager.semanticInfo("FUNCION: "+idFunc.getLexema()+" en la linea: "+idFunc.getLine());
 				// la funcion ha sido declarada
                            if (scopeManager.containsSymbol(idFunc.getLexema())) {
				semanticErrorManager.semanticFatalError("350. La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" ya ha sido declarada");
                            }else{ 
                                
								// Crear FUNCION en ambito
								ScopeIF scope = scopeManager.getCurrentScope();
                                TypeTableIF tablaTipos = scope.getTypeTable();
	  							SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
                                // a�adir funcion a TT
                               	TypeFunction tipoFuncion = new TypeFunction(scope, idFunc.getLexema());
								tablaTipos.addType(idFunc.getLexema(), tipoFuncion);
							
								// a�adir funcion a TS
                                SymbolFunction simboloFunc = new SymbolFunction(scope,idFunc.getLexema(),tablaTipos.getType(idFunc.getLexema()));
								tablaSimbolos.addSymbol(idFunc.getLexema(), simboloFunc);
							
								// NUEVO ambito para funcion y tabla TS y TT
								scopeManager.openScope(idFunc.getLexema()); 
                                
														
								tablaTipos = scopeManager.getCurrentScope().getTypeTable();
								tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

                                // Grabo tipo retorno
								tipoFuncion.setTipoRetorno(scopeManager.searchType(tp.toString()));

					 
       
                				tipoFuncion.setHayRetorno(true);
                               
                                
                              }
:} 
cabecera:bloque1 cuerpoFuncion:bloque2 {:
                                BloqueSentencias bloque = new BloqueSentencias();
                               
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeFunction tipoFuncion = (TypeFunction) scopeManager.searchType(scope.getName());
                                

                                // Cerramos Scope
                               scopeManager.closeScope();

                                // Comprobar que hay return de la funcion

                                if  (! tipoFuncion.getHayRetorno())
                                    semanticErrorManager.semanticFatalError("352. La funcion "+tipoFuncion.getName()+" no tiene retorno"); 
                                RESULT=bloque;
              
:}; 
funcion::= FUNCTION ID:idFunc PARENTESISIZQ lista_parametros:listaArg PARENTESISDER RETURN tipos:tp IS
{:
				semanticErrorManager.semanticInfo("FUNCION: "+idFunc.getLexema()+" en la linea: "+idFunc.getLine());
 				// la funcion ha sido declarada
                            if (scopeManager.containsSymbol(idFunc.getLexema())) {
				semanticErrorManager.semanticFatalError("350. La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" ya ha sido declarada");
                            }else{ 
                                
				// Crear FUNCION en ambito
				ScopeIF scope = scopeManager.getCurrentScope();
                                TypeTableIF tablaTipos = scope.getTypeTable();
	  			SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
                                // a�adir funcion a TT
                               	TypeFunction tipoFuncion = new TypeFunction(scope, idFunc.getLexema());
				tablaTipos.addType(idFunc.getLexema(), tipoFuncion);
							
				// a�adir funcion a TS
                                SymbolFunction simboloFunc = new SymbolFunction(scope,idFunc.getLexema(),tablaTipos.getType(idFunc.getLexema()));
				tablaSimbolos.addSymbol(idFunc.getLexema(), simboloFunc);
							
				// NUEVO ambito para funcion y tabla TS y TT
				scopeManager.openScope(idFunc.getLexema()); 
                                
														
				tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

                                // Grabo tipo retorno
				tipoFuncion.setTipoRetorno(scopeManager.searchType(tp.toString()));

				// Grabo parametros funcion
                                // ListaObjetos parametros = new ListaObjetos(listaArg) 
				ArrayList parametros = new ArrayList(Utilidades.ordenaParametros(listaArg));
                                
        			for (int i=0; i<parametros.size(); i++){
                                    Parametro p = (Parametro) parametros.get(i);
                                    SymbolVariable simboloVar = new SymbolVariable (scopeManager.getCurrentScope(), p.getNombre(), p.getTipo());
                                    
                                    // Creo lista ordenada de parametros en el PROCEDIMIENTO.
                                    tipoFuncion.setTypeParametro(p.getColumna(),p.getTipo()); 
                                    // Fijar paso parametros Ref/Valor en Symbolvar
                                    simboloVar.setReferencia(p.getReferencia());
                                    tablaSimbolos.addSymbol(p.getNombre(),simboloVar);                                  	
                                    tipoFuncion.setParametro(simboloVar);
                                } 
       
                                tipoFuncion.setHayRetorno(true);
                               
                                
                              }
:} 
cuerpoFuncion:bloque2 {:
                                BloqueSentencias bloque = new BloqueSentencias();
                               
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeFunction tipoFuncion = (TypeFunction) scopeManager.searchType(scope.getName());
                                

                                // Cerramos Scope
                               scopeManager.closeScope();

                                // Comprobar que hay return de la funcion

                                if  (! tipoFuncion.getHayRetorno())
                                    semanticErrorManager.semanticFatalError("352. La funcion "+tipoFuncion.getName()+" no tiene retorno"); 
                                RESULT=bloque;
              
:};
funcion::= FUNCTION ID:idFunc PARENTESISIZQ PARENTESISDER RETURN tipos:tp IS 
{:
			semanticErrorManager.semanticInfo("FUNCION: "+idFunc.getLexema()+" en la linea: "+idFunc.getLine());
               
 				// la funcion ha sido declarada
                            if (scopeManager.containsSymbol(idFunc.getLexema())) {
				semanticErrorManager.semanticFatalError("350. La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" ya ha sido declarada");
                            }else{ 
                                
				// Crear FUNCION en ambito
				ScopeIF scope = scopeManager.getCurrentScope();
                                TypeTableIF tablaTipos = scope.getTypeTable();
	  			SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
                                // a�adir funcion a TT
                               	TypeFunction tipoFuncion = new TypeFunction(scope, idFunc.getLexema());
				tablaTipos.addType(idFunc.getLexema(), tipoFuncion);
							
				// a�adir funcion a TS
                                SymbolFunction simboloFunc = new SymbolFunction(scope,idFunc.getLexema(),tablaTipos.getType(idFunc.getLexema()));
				tablaSimbolos.addSymbol(idFunc.getLexema(), simboloFunc);
							
				// NUEVO ambito para funcion y tabla TS y TT
				scopeManager.openScope(idFunc.getLexema()); 
                                
														
				tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

                                // Grabo tipo retorno
				tipoFuncion.setTipoRetorno(scopeManager.searchType(tp.toString()));

					 
       
                tipoFuncion.setHayRetorno(true);
                               
                                
                              }
:} 
cuerpoFuncion:bloque2 {:
                                BloqueSentencias bloque = new BloqueSentencias();
                               
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeFunction tipoFuncion = (TypeFunction) scopeManager.searchType(scope.getName());
                                

                                // Cerramos Scope
                               scopeManager.closeScope();

                                // Comprobar que hay return de la funcion

                                if  (! tipoFuncion.getHayRetorno())
                                    semanticErrorManager.semanticFatalError("352. La funcion "+tipoFuncion.getName()+" no tiene retorno"); 
                                RESULT=bloque;
              
:};  
funcion::= FUNCTION ID error RETURN tipos IS cuerpoFuncion {:syntaxErrorManager.syntaxFatalError("001. Faltan los DOS PARENTESIS");:};
			
cuerpoFuncion::= BEGIN listaSentencias:bloque RETURN expresion:exp PUNTOYCOMA END ID PUNTOYCOMA
{:
				 RESULT=bloque;
					 :}  |
				BEGIN RETURN expresion:exp PUNTOYCOMA END ID PUNTOYCOMA
				{:
				BloqueSentencias bloque = new BloqueSentencias();
				 RESULT=bloque;
					 :} ;

// ----------------------------                     
// Definicion de PROCEDIMIENTO
// ----------------------------  
procedimiento::= PROCEDURE ID:idProc PARENTESISIZQ lista_parametros:listaArg PARENTESISDER IS
{:
				semanticErrorManager.semanticInfo("PROCEDIMIENTO: "+idProc.getLexema()+" en la linea: "+idProc.getLine());
 				// el procedimiento ha sido declarado
                            if (scopeManager.containsSymbol(idProc.getLexema())) {
				semanticErrorManager.semanticFatalError("350. El procediiento "+idProc.getLexema()+" en la linea: "+idProc.getLine()+" ya ha sido declarado");
                            }else{ 
                                
				// Crear FUNCION en ambito
				ScopeIF scope = scopeManager.getCurrentScope();
                TypeTableIF tablaTipos = scope.getTypeTable();
	  			SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
                // a�adir funcion a TT
                TypeProcedure tipoProcedimiento = new TypeProcedure(scope, idProc.getLexema());
				tablaTipos.addType(idProc.getLexema(), tipoProcedimiento);
							
				// a�adir funcion a TS
                 SymbolProcedure simboloProc = new SymbolProcedure(scope,idProc.getLexema(),tablaTipos.getType(idProc.getLexema()));
				tablaSimbolos.addSymbol(idProc.getLexema(), simboloProc);
							
				// NUEVO ambito para funcion y tabla TS y TT
				scopeManager.openScope(idProc.getLexema()); 
                                
														
				tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();


				// Grabo parametros funcion
                // ListaObjetos parametros = new ListaObjetos(listaArg) 
				ArrayList parametros = new ArrayList(Utilidades.ordenaParametros(listaArg));
                                
        			for (int i=0; i<parametros.size(); i++){
                                    Parametro p = (Parametro) parametros.get(i);
                                    SymbolVariable simboloVar = new SymbolVariable (scopeManager.getCurrentScope(), p.getNombre(), p.getTipo());
                                    
                                    // Creo lista ordenada de parametros en el PROCEDIMIENTO.
                                    tipoProcedimiento.setTypeParametro(p.getColumna(),p.getTipo()); 
                                    // Fijar paso parametros Ref/Valor en Symbolvar
                                    simboloVar.setReferencia(p.getReferencia());
                                    tablaSimbolos.addSymbol(p.getNombre(),simboloVar);                                  	
                                    tipoProcedimiento.setParametro(simboloVar);
                                } 

                               
                                
                              }
:} 
cabecera:bloque1 cuerpo:bloque2 {:
                                BloqueSentencias bloque = new BloqueSentencias();
                               
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeProcedure tipoProcedimiento = (TypeProcedure) scopeManager.searchType(scope.getName());
                                

                                // Cerramos Scope
                               scopeManager.closeScope();

                                 RESULT=bloque;
              
:};
procedimiento::= PROCEDURE ID:idProc PARENTESISIZQ lista_parametros:listaArg PARENTESISDER IS
{:
				semanticErrorManager.semanticInfo("PROCEDIMIENTO: "+idProc.getLexema()+" en la linea: "+idProc.getLine());
 				
 				// el procedimiento ha sido declarado
                            if (scopeManager.containsSymbol(idProc.getLexema())) {
				semanticErrorManager.semanticFatalError("350. El procediiento "+idProc.getLexema()+" en la linea: "+idProc.getLine()+" ya ha sido declarado");
                            }else{ 
                                
				// Crear FUNCION en ambito
				ScopeIF scope = scopeManager.getCurrentScope();
                TypeTableIF tablaTipos = scope.getTypeTable();
	  			SymbolTableIF tablaSimbolos = scope.getSymbolTable();
							
                // a�adir funcion a TT
                TypeProcedure tipoProcedimiento = new TypeProcedure(scope, idProc.getLexema());
				tablaTipos.addType(idProc.getLexema(), tipoProcedimiento);
							
				// a�adir funcion a TS
                 SymbolProcedure simboloProc = new SymbolProcedure(scope,idProc.getLexema(),tablaTipos.getType(idProc.getLexema()));
				tablaSimbolos.addSymbol(idProc.getLexema(), simboloProc);
							
				// NUEVO ambito para funcion y tabla TS y TT
				scopeManager.openScope(idProc.getLexema()); 
                                
														
				tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();


				// Grabo parametros funcion
                // ListaObjetos parametros = new ListaObjetos(listaArg) 
				ArrayList parametros = new ArrayList(Utilidades.ordenaParametros(listaArg));
                                
        			for (int i=0; i<parametros.size(); i++){
                                    Parametro p = (Parametro) parametros.get(i);
                                    SymbolVariable simboloVar = new SymbolVariable (scopeManager.getCurrentScope(), p.getNombre(), p.getTipo());
                                    
                                    // Creo lista ordenada de parametros en el PROCEDIMIENTO.
                                    tipoProcedimiento.setTypeParametro(p.getColumna(),p.getTipo()); 
                                    // Fijar paso parametros Ref/Valor en Symbolvar
                                    simboloVar.setReferencia(p.getReferencia());
                                    tablaSimbolos.addSymbol(p.getNombre(),simboloVar);                                  	
                                    tipoProcedimiento.setParametro(simboloVar);
                                } 

                               
                                
                              }
:} 
cuerpo:bloque2 {:
                                BloqueSentencias bloque = new BloqueSentencias();
                               
                                ScopeIF scope = scopeManager.getCurrentScope();
                                TypeProcedure tipoProcedimiento = (TypeProcedure) scopeManager.searchType(scope.getName());
                                

                                // Cerramos Scope
                               scopeManager.closeScope();

                                 RESULT=bloque;
              
:};

// ----------------------------                     
// Definicion de SENTENCIAS		
// ---------------------------- 
listaSentencias::= sentencia:sent {:
                                RESULT=sent;
					:}  | listaSentencias:blq sentencia:sent{:
					BloqueSentencias bloque = new BloqueSentencias();
                                       
					RESULT=bloque;

				    :};

sentencia::=sentenciaAsignacion:sent {: RESULT=sent; :}| 
			sentenciaIf:sent {: RESULT=sent; :} | 
			sentenciaWhile:sent {: RESULT=sent; :} | 
			sentenciaPutLine:sent {: RESULT=sent; :} | 
			sentenciaProcedimiento:sent {: RESULT=sent; :};

// ------------------------
// Sentencia PUTLINE
// ------------------------
sentenciaPutLine::= PUTLINE:id PARENTESISIZQ CARACTERESCADENA:cad PARENTESISDER PUNTOYCOMA
{:

     			semanticErrorManager.semanticInfo ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] es una CADENA DE CARACTERES.");
       			
       			BloqueSentencias bloque = new BloqueSentencias();
     			ScopeIF scope = scopeManager.getCurrentScope();
				
                
                semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
					RESULT=bloque;		
				:};

sentenciaPutLine::= PUTLINE:id PARENTESISIZQ expresion:exp PARENTESISDER PUNTOYCOMA
{:    
            BloqueSentencias bloque = new BloqueSentencias();
            ScopeIF scope = scopeManager.getCurrentScope();

            
            semanticErrorManager.semanticDebug(bloque.getIntermediateCode());

			RESULT=bloque;
	   :}; 


//parametroPutLine::= cadenaCaracteres  | expresion;
//cadenaCaracteres::= CARACTERESCADENA;
// ------------------------
// Sentencia WHILE
// ------------------------
sentenciaWhile::= WHILE:id expresion:exp LOOP listaSentencias:sent END LOOP PUNTOYCOMA{:

		semanticErrorManager.semanticInfo("Sentencia WHILE en [" + id.getLine() + ":" + id.getColumn() + "]");
                              if ( !(exp.getTipo().getName().equals("BOOLEAN")) )
                                    semanticErrorManager.semanticFatalError ("326. La expresion sentencia WHILE no es BOOLEANA.");
                              BloqueSentencias bloque = new BloqueSentencias();
                              ScopeIF scope = scopeManager.getCurrentScope();
					
                             
                              RESULT=bloque;
                            :};

// ------------------------
// Sentencia IF
// ------------------------
sentenciaIf::= IF:id expresion:exp THEN listaSentencias:sent END IF PUNTOYCOMA
{:
					//semanticErrorManager.semanticInfo ("Sentencia IF simple en [" +id.getLine() + ":" + id.getColumn()+"]");
                            if ( !(exp.getTipo().getName().equals("BOOLEAN")) ) 
                                  semanticErrorManager.semanticFatalError ("328. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es LOGICA.");
                                  BloqueSentencias bloque = new BloqueSentencias();
				  				  ScopeIF scope = scopeManager.getCurrentScope();

                                  
                                  semanticErrorManager.semanticDebug(bloque.getIntermediateCode());
                                  RESULT=bloque;

					:};
sentenciaIf::= IF:id expresion:exp THEN listaSentencias:sent1 ELSE listaSentencias:sent2 END IF PUNTOYCOMA
{:
			//semanticErrorManager.semanticInfo ("Sentencia IF con ELSE en [" +id.getLine() + ":" + id.getColumn()+"]");
                               
                            if ( !(exp.getTipo().getName().equals("BOOLEAN")) ) 
                                semanticErrorManager.semanticFatalError ("330. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es LOGICA.");
                                BloqueSentencias bloque = new BloqueSentencias();
								ScopeIF scope = scopeManager.getCurrentScope();


                                RESULT=bloque;
				:};

// ------------------------
// Sentencia ASIGNACION
// ------------------------
sentenciaAsignacion::= ID:id ASIGNACION expresion:exp PUNTOYCOMA
{:

							semanticErrorManager.semanticInfo ("Sentencia ASIGNACION " + id.getLexema() + ":= " + exp.getTipo().getName()+" en [" +id.getLine() + ":" + id.getColumn()+"]");

							BloqueSentencias bloque = new BloqueSentencias();
                            ScopeIF scope = scopeManager.getCurrentScope();
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                            
                            // Hay que tener en cuenta que puede ser el ID de una funcion
                            if (!(scopeManager.containsSymbol(id.getLexema()))) {
                                semanticErrorManager.semanticFatalError ("274. La variable: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                            } else {
								SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                                //TypeIF tipo = simbolo.getType();

									// Comprobamos que no es una constante
									if (simbolo instanceof SymbolConstant)
                                    semanticErrorManager.semanticFatalError ("276. La constante: " + id.getLexema() +" en [" + 
                                    id.getLine() + ":" + id.getColumn() + "] no admite asignaciones.");
                                    
                                  	TypeIF tipo = exp.getTipo();
                                  

                                	semanticErrorManager.semanticInfo ("Sentencia asignacion. Tipo de la EXPRESION: "+tipo.getName()+ " en [" + id.getLine() + ":" + id.getColumn() + "]");

			            
	                                // Comprobaciones en el caso de una funcion	
	                                if (tipo instanceof TypeFunction ) {

                                    TypeFunction tipoFuncion = (TypeFunction) tipo;
                                    // El tipo de retorno debe ser igual que la expresion
                                     
                                    if ( !(tipoFuncion.getTipoRetorno() == exp.getTipo()) ) 
                                        semanticErrorManager.semanticFatalError ("278. El tipo retorno funcion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no coincide con la expresion.");
                                     // Es una funcion y si hay asignacion de retorno
                                     tipoFuncion.setHayRetorno(true);
                                     
                                     Variable var = new Variable(id.getLexema(), scope);
                                     var.setAmbito(tipo.getScope());
                                     LabelIF label = tipoFuncion.getEtiqSubFin();
                                     var.setEtiqRetorno(label);
                                     List code1 = exp.getIntermediateCode();
                                     cb.addQuadruples (code1);
                                
                                     cb.addQuadruple("RET", var, exp.getResultado());
                                     
                                    

                                     
                                    
                                } /*else {

                                    // SOY UNA ASIGNACION CONJUNTOS

                                    if (tipo instanceof TypeSet) {
 
                                        if ( !(tipo.getName() == exp.getTipo().getName()) ) 
                                            semanticErrorManager.semanticFatalError ("280. La expresion no se puede asignar a un Tipo CONJUNTO: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "]");
                                        
                                         

                                    }else {
                                        // No se permiten asignaciones tipo record
                                        if (tipo instanceof TypeRecord)
                                            semanticErrorManager.semanticFatalError ("282. No se permiten asignaciones tipo record: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "]");
                                    
                                        // Si no son mismo tipo. ID debe ser expresion ENTERA
                                        if ( !(tipo.getName() == exp.getTipo().getName()) ){ 
                                            if ( (tipo.getName().equals("INTEGER")&& exp.getTipo().getName().equals("POINTER")) ){
                                            
                                            }else{
                                                semanticErrorManager.semanticFatalError ("284. La Asignacion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no coincide en tipos.");
                                            }                
                                     }


                                   
                                  }    
                                }   */
                                                               
                           			
                                
                               	semanticErrorManager.semanticDebug(bloque.getIntermediateCode());

                                RESULT=bloque;
					
                             }
                		:};//x:=t-r;   z:= resta (a,b);

sentenciaAsignacion::= ID:id PUNTO ID:campo ASIGNACION expresion:exp PUNTOYCOMA {:

					semanticErrorManager.semanticInfo ("Sentencia ASIGNACION " + id.getLexema() + ":= " + exp.getTipo().getName()+" en [" +id.getLine() + ":" + id.getColumn()+"]");
			
                            if ( !(scopeManager.containsSymbol(id.getLexema())) ) {
                                semanticErrorManager.semanticFatalError ("286. La variable: " + id.getLexema() +" en [" + 
								id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                            } else {
	                        SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                                TypeIF tipo = scopeManager.searchType(simbolo.getType().getName());

				if ( !(tipo instanceof TypeRecord) ) 
					semanticErrorManager.semanticFatalError ("290. La variable: " + id.getLexema() +" en [" + 
								id.getLine() + ":" + id.getColumn() + "] no es un tipo RECORD.");
				TypeRecord tipoRec = (TypeRecord) scopeManager.searchType(simbolo.getType().getName());
				if ( tipoRec.getTypeCampo(campo.getLexema()) == null ) 
                              		semanticErrorManager.semanticFatalError ("292. El campo del REG: " + campo.getLexema() +" en [" + 
							campo.getLine() + ":" + campo.getColumn() + "] no ha sido definido.");
                                
                                // Si no son mismo tipo. ID.campo debe ser expresion ENTERA
                                if ( !(tipoRec.getTypeCampo(campo.getLexema()).getName().equals(exp.getTipo().getName())) ){ 
                                    if ( (tipoRec.getTypeCampo(campo.getLexema()).getName().equals("INTEGER")&& exp.getTipo().getName().equals("POINTER")) ){
    			            }else{
                                         semanticErrorManager.semanticFatalError ("294. La Asignacion: " + id.getLexema() +" en [" + 
                                               	id.getLine() + ":" + id.getColumn() + "] no coincide en tipos.");
                                        }                
                                    }
					
                                    ScopeIF scope = scopeManager.getCurrentScope();
                                   
                                    BloqueSentencias bloque = new BloqueSentencias();
                                   				
                                    RESULT=bloque;
														
                    		}
				:};

sentenciaAsignacion::= ID PUNTO ID PUNTO ID ASIGNACION expresion PUNTOYCOMA;

sentenciaAsignacion::= ID:id PARENTESISIZQ ENTERO:num PARENTESISDER ASIGNACION expresion:exp PUNTOYCOMA
{:
		semanticErrorManager.semanticInfo ("Sentencia ASIGNACION " + id.getLexema() + ":= " + exp.getTipo().getName()+" en [" +id.getLine() + ":" + id.getColumn()+"]");
			
                            ScopeIF scope = scopeManager.getCurrentScope();
                            BloqueSentencias bloque = new BloqueSentencias();
                            // Existe la variable vector
                            if (!(scopeManager.containsSymbol(id.getLexema())) ) 
                                semanticErrorManager.semanticFatalError ("310. El VECTOR: " + id.getLexema() +" en [" + 
						id.getLine() + ":" + id.getColumn() + "] no ha sido definido.");
                            
                            SymbolVariable simbolo = (SymbolVariable) scopeManager.searchSymbol(id.getLexema());
                            
                            // Existe la var y es del tipo vector
                            if (! (simbolo.getType() instanceof TypeArray)) 
                                semanticErrorManager.semanticFatalError ("312. El ID: " + id.getLexema() +" en [" + 
						id.getLine() + ":" + id.getColumn() + "] no es un tipo CONJUNTO.");
                            
                            semanticErrorManager.semanticInfo ("VECTOR--> "+id.getLexema()+" de tipo : "+ simbolo.getType().getName());
                            
                            // Asignacion entre limites
                            TypeArray tipoArray = (TypeArray) simbolo.getType();
                            int n = Integer.parseInt(num.getLexema());
                            if (n < tipoArray.getValIni() || n > tipoArray.getValFin())
                                semanticErrorManager.semanticFatalError ("314. El rango del vector: " + id.getLexema() +" en [" + 
						id.getLine() + ":" + id.getColumn() + "] no esta dentro de los limites del mismo.");

                          	semanticErrorManager.semanticInfo ("El valor '"+ num.getLexema() + "' esta dentro de los limites ["+tipoArray.getValIni()+","+tipoArray.getValFin()+"]");
                           	
                           	// Comprobacion de tipos (vector y expresion)
						if ( !(simbolo.getType().getName().equalsIgnoreCase(exp.getTipo().getName())) ) {	
							TypeIF tipoVar=scopeManager.searchType(simbolo.getType().getName());
                        	if ( !(simbolo.getType().getName().equalsIgnoreCase(tipoVar.getName())))  
                            //       }else {
                                        semanticErrorManager.semanticFatalError ("308. El ID: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no son compatibles.");
                            //        }					   
				      
                            //    }
                            }					
                            RESULT = bloque;
                        :}; //vE(1):=20;


//vector::= ID:id PARENTESISIZQ ENTERO:num PARENTESISDER;

// ------------------------
// Sentencia FUNCION
// ------------------------
sentenciaFuncion ::= ID:idFunc PARENTESISIZQ lista_parametros_llamada:listaPar PARENTESISDER
{:
					semanticErrorManager.semanticInfo("Sentencia FUNCION en la linea: "+idFunc.getLine()+ " y columna "+idFunc.getColumn());
	                    
 					ScopeIF scope = scopeManager.getCurrentScope();
            		    SymbolTableIF tablaSimbolos = scope.getSymbolTable();
                            TypeTableIF tablaTipos = scope.getTypeTable();
			    
                            // Si la funcion ha sido declarada
		      	    if (!(scopeManager.containsSymbol(idFunc.getLexema()))) 
                                semanticErrorManager.semanticFatalError("340. La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" NO ha sido declarada");
	                    
                            // Si es un tipo Funcion
                            SymbolIF func = scopeManager.searchSymbol(idFunc.getLexema());
                            if (! (func.getType() instanceof TypeFunction) )
				    semanticErrorManager.semanticFatalError("342. La funcion "+idFunc.getLexema()+" en la linea: "+idFunc.getLine()+" NO es un FUNCTION");
	            	        
            		    // num de parametros sea el mismo que argumentos y sea correcto por REF/Valor
	            	    TypeFunction tipoFunc = (TypeFunction) func.getType();
                            ListaObjetos lista = new ListaObjetos(listaPar);

                            // Coincidencia de Tipos y numero entre la Def de la funcion y la llamada
		  	    		if (!tipoFunc.comparaParametros(listaPar)) 
                                  semanticErrorManager.semanticFatalError ("344. El num. de parametros no coincide en tipos o numero para la funci�n " + idFunc.getLexema() + " [" + idFunc.getLine() + ":" + idFunc.getColumn() + "]");
            		    
                            Expresion exp = new Expresion(tipoFunc.getTipoRetorno(), idFunc.getLine(), idFunc.getColumn());
                            
                            
                            RESULT=exp;
			:};

lista_parametros_llamada::= expresion:exp {:
                ListaObjetos lista = new ListaObjetos();
			    lista.add(exp);
                RESULT=lista; :};
lista_parametros_llamada::= expresion:exp COMA lista_parametros_llamada:listaPar {:
                            ListaObjetos lista = new ListaObjetos(listaPar);
                            lista.add(exp);
                            RESULT=lista;
                            :};

// ------------------------
// Sentencia PROCEDIMIENTO
// ------------------------
//sentenciaProcedimiento::= idTipos ASIGNACION ID PARENTESISIZQ lista_parametros_llamada PARENTESISDER PUNTOYCOMA;
sentenciaProcedimiento::= ID:idProc PARENTESISIZQ lista_parametros_llamada:listaPar PARENTESISDER PUNTOYCOMA
						{:
						
						 semanticErrorManager.semanticInfo("Sentencia PROCEDIMIENTO "+idProc.getLexema()+" en la linea: "+idProc.getLine());
						
                            ScopeIF scope = scopeManager.getCurrentScope();
	         	    		SymbolTableIF tablaSimbolos = scope.getSymbolTable();
	                    	TypeTableIF tablaTipos = scope.getTypeTable();
				
                            // Si Procedimiento ha sido declarado
		      	    		if (!(scopeManager.containsSymbol(idProc.getLexema()))) 
                                semanticErrorManager.semanticFatalError("332. El procedimiento "+idProc.getLexema()+" en la linea: "+idProc.getLine()+" NO ha sido declarada");

                            // Si es un tipo Procedure    
                            SymbolIF proc = scopeManager.searchSymbol(idProc.getLexema());
                            TypeIF tipo = scopeManager.searchType(idProc.getLexema());
                            if (! (tipo instanceof TypeProcedure) )
                                        semanticErrorManager.semanticFatalError("334. El ID "+idProc.getLexema()+" en la linea: "+idProc.getLine()+" NO es un PROCEDIMIENTO");
	            
                            // num de parametros sea el mismo que argumentos y sea correcto por REF/VALOR
	            	    	TypeProcedure tipoProc = (TypeProcedure) proc.getType();
                            ListaObjetos lista = new ListaObjetos(listaPar);

                            // Coincidencia de Tipos y numero entre la Def del procedimiento y la llamada
                            if (!tipoProc.comparaParametros(listaPar)) 
                                semanticErrorManager.semanticFatalError ("336. El num. de parametros no coincide en para el procedimiento " + idProc.getLexema() + " [" + idProc.getLine() + ":" + idProc.getColumn() + "]");
            		    
                            BloqueSentencias bloque = new BloqueSentencias();

			    RESULT = bloque;
                            :};

// --------------------
// Expresion 
// --------------------
expresion::=expresion:exp1 MENOS:id expresion:exp2
{:
                            Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                            if (exp.castingTipos(exp1 , exp2) ) {
                                 semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            }else{
                            	ScopeIF scope = scopeManager.getCurrentScope();

                            	
								
                                semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
								RESULT=exp;

                             }

					:}; 
expresion::= expresion:exp1 MAS:id expresion:exp2
{:
                            ScopeIF scope = scopeManager.getCurrentScope();
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                            Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                            TemporalFactoryIF tf = CompilerContext.getTemporalFactory(scope);				
                            Temporal temporal = (Temporal) tf.create(); 
                            
						 // Suma CONJUNTOS
                     /*       if (exp1.getTipo().equals(exp2.getTipo()) && exp1.getTipo() instanceof TypeSet) {
                                TypeSet tipoSet = (TypeSet) exp1.getTipo();
                                exp.setTipo(exp1.getTipo());
                                
                            // Suma ENTEROS y/o PUNTEROS  
                            } else {
                                if (exp.castingTipos(exp1 , exp2) )
                                     semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + 
                                        id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                                  

                            }*/
                            

                           

                           
                           	semanticErrorManager.semanticDebug(exp.getIntermediateCode());		

                            RESULT=exp;
                            :} | 
			expresion:exp1 OR:id expresion:exp2 {:
                            if ( !(exp1.getTipo() == exp2.getTipo()) || !(exp1.getTipo().getName().equals("BOOLEAN")) || !(exp2.getTipo().getName().equals("BOOLEAN")) ) {
                                semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            }else{
		      	        		Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
								ScopeIF scope = scopeManager.getCurrentScope();
				

                                
       			
              
					semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
                    RESULT=exp;
                            }
        		:}| 
			expresion:exp1 AND:id expresion:exp2 {:
                            if ( !(exp1.getTipo() == exp2.getTipo()) || !(exp1.getTipo().getName().equals("BOOLEAN")) || !(exp2.getTipo().getName().equals("BOOLEAN")) ) {
                                semanticErrorManager.semanticFatalError ("228. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            }else{

				      	        Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
								ScopeIF scope = scopeManager.getCurrentScope();
							 


        		
					semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
                    RESULT=exp;
                            }
        		:} | 
			expresion:exp1 MAYORQUE:id expresion:exp2 
{:
			    if ( !(exp1.getTipo() == exp2.getTipo())  ||  !(exp1.getTipo().getName().equals("INTEGER"))  || !(exp2.getTipo().getName().equals("INTEGER")) )  {
                                  semanticErrorManager.semanticFatalError ("230. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			     }else{

			      	          	  Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
					  			  ScopeIF scope = scopeManager.getCurrentScope();
				 				  
				  

				  
				  semanticErrorManager.semanticDebug(exp.getIntermediateCode());		

				  RESULT=exp;
				}
					:} | 
			expresion:exp1 MENORQUE:id expresion:exp2 
{:
			    if ( !(exp1.getTipo() == exp2.getTipo())  ||  !(exp1.getTipo().getName().equals("INTEGER"))  || !(exp2.getTipo().getName().equals("INTEGER")) )  {
                                  semanticErrorManager.semanticFatalError ("232. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			     }else{

		      	          		  Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
				  				  ScopeIF scope = scopeManager.getCurrentScope();
				 				  

						
					semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
				  	RESULT=exp;
				}
					:} | 
			expresion:exp1 IGUALQUE:id expresion:exp2 {:
                            if ( !(exp1.getTipo() == exp2.getTipo()) )
                                  semanticErrorManager.semanticFatalError ("234. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            if ( (exp1.getTipo() instanceof TypeRecord) || exp1.getTipo() instanceof TypeSet )
                                  semanticErrorManager.semanticFatalError ("236. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no permitida para este tipo.");
                            
                            Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                            ScopeIF scope = scopeManager.getCurrentScope();


                            semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
				  			RESULT=exp;

                  	:} | 
			expresion:exp1 DISTINTOQUE:id expresion:exp2
			{:
                            if ( !(exp1.getTipo() == exp2.getTipo()) )
                                  semanticErrorManager.semanticFatalError ("238. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            if ( (exp1.getTipo() instanceof TypeRecord) || exp1.getTipo() instanceof TypeSet )
                                  semanticErrorManager.semanticFatalError ("240. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no permitida para este tipo.");
                     
                            Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                            ScopeIF scope = scopeManager.getCurrentScope();
                           

                            
                            
                            semanticErrorManager.semanticDebug(exp.getIntermediateCode());		
				  			RESULT=exp;

                            :} | 
			PARENTESISIZQ expresion:exp PARENTESISDER {: 
					semanticErrorManager.semanticDebug(exp.getIntermediateCode());
					RESULT=exp; 
                            :}; //Vector
expresion::= ID:id
{:
				ScopeIF scope = scopeManager.getCurrentScope();
			        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
                  		TypeTableIF tablaTipos = scope.getTypeTable();
			        if (!(scopeManager.containsSymbol(id.getLexema()))) {
                                    semanticErrorManager.semanticFatalError ("242. La variable: " + id.getLexema() +" en [" + 
									id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                    		} else {
                                    SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                                    Expresion exp = new Expresion(simbolo.getType(), id.getLine(), id.getColumn());
                                    if (simbolo instanceof SymbolConstant) {
					SymbolConstant simboloCte = (SymbolConstant) simbolo;
					Value valor=new Value(simboloCte.getValue());
                                        exp.setResultado(valor);
				    }else{

                               			     

				       
                                    }
                                semanticErrorManager.semanticDebug(exp.getIntermediateCode());
                       		    RESULT = exp;
                    		}
                		:};
expresion::= ENTERO:num {:
                            ScopeIF scope = scopeManager.getCurrentScope();
	      	            	Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), num.getLine(), num.getColumn());
			    			Value resultado=new Value(Integer.parseInt(num.getLexema()));
                            exp.setResultado(resultado);  // Guardamos el valor operador
                
			                semanticErrorManager.semanticDebug(exp.getIntermediateCode());
						    RESULT = exp;
			                            :}|
			ID:id PUNTO ID:campo {:
			    if ( !(scopeManager.containsSymbol(id.getLexema())) ) {
                                  semanticErrorManager.semanticFatalError ("244. El tipo registro: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                            }
                            ScopeIF scope = scopeManager.getCurrentScope();
                            SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                            TypeRecord tipoRecord = (TypeRecord) scopeManager.searchType(simbolo.getType().getName());

                            // El campo existe en el Registro
                            if (! tipoRecord.containsCampo(campo.getLexema() )) {
                                    semanticErrorManager.semanticFatalError ("246. El campo registro: " + campo.getLexema() +" en [" + 
							campo.getLine() + ":" + campo.getColumn() + "] no ha sido definida.");
                            }                            
                            Expresion exp = new Expresion(tipoRecord.getTypeCampo(campo.getLexema()), campo.getLine(), campo.getColumn());
                            HashMap tablaCampos = tipoRecord.getTablaCampos();
                            SymbolVariable simboloCampo = (SymbolVariable) tablaCampos.get(campo.getLexema()); 



                            



                            semanticErrorManager.semanticDebug(exp.getIntermediateCode());
						    RESULT = exp;
                		:}|
			ID PUNTO ID PUNTO ID  |
			sentenciaFuncion:exp {:
                                RESULT=exp;									
                            :} |
			tipoBooleano :id {:
                            ScopeIF scope = scopeManager.getCurrentScope();
	      	            	Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                            // Le damos el valor true=1 y false=0
                            Value resultado=new Value(0);
                            if (id.getLexema().equalsIgnoreCase("TRUE")){
								resultado=new Value(1);
                            }
							exp.setResultado(resultado);
							
                                RESULT=exp;			
                         :} |
			ID:id PARENTESISIZQ ENTERO:num PARENTESISDER {:
					ScopeIF scope = scopeManager.getCurrentScope();
			        SymbolTableIF tablaSimbolos = scope.getSymbolTable();
                  		TypeTableIF tablaTipos = scope.getTypeTable();
			        if (!(scopeManager.containsSymbol(id.getLexema()))) {
                                    semanticErrorManager.semanticFatalError ("242. La variable: " + id.getLexema() +" en [" + 
									id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                    } else {
                                    SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                                    Expresion exp = new Expresion(simbolo.getType(), id.getLine(), id.getColumn());
                                    
                                    
                                    
                                    
                                    // Existe la var y es del tipo vector
                            if (! (simbolo.getType() instanceof TypeArray)) 
                                semanticErrorManager.semanticFatalError ("312. El ID: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es un tipo CONJUNTO.");
                            
                            semanticErrorManager.semanticInfo ("VECTOR--> "+id.getLexema()+" de tipo : "+ simbolo.getType().getName());
                            
                            // Asignacion entre limites
                            TypeArray tipoArray = (TypeArray) simbolo.getType();
                            int n = Integer.parseInt(num.getLexema());
                            if (n < tipoArray.getValIni() || n > tipoArray.getValFin())
                                semanticErrorManager.semanticFatalError ("314. El rango del vector: " + id.getLexema() +" en [" + 
						id.getLine() + ":" + id.getColumn() + "] no esta dentro de los limites del mismo.");

                          	semanticErrorManager.semanticInfo ("El valor '"+ num.getLexema() + "' esta dentro de los limites ["+tipoArray.getValIni()+","+tipoArray.getValFin()+"]");
                           	
                           	// Comprobacion de tipos (vector y expresion)
						if ( !(simbolo.getType().getName().equalsIgnoreCase(exp.getTipo().getName())) ) {	
							TypeIF tipoVar=scopeManager.searchType(simbolo.getType().getName());
                        	if ( !(simbolo.getType().getName().equalsIgnoreCase(tipoVar.getName())))  
                                        semanticErrorManager.semanticFatalError ("308. El ID: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no son compatibles.");
                       }					
                            

			
                                RESULT=exp;	
                              }								
                            :};//v(1)

// -------------
// Definiciones
// -------------
//tipoPrimitivo::= ENTERO | tipoBooleano;
tipoBooleano::= TRUE:id {: RESULT=id; :} | FALSE:id {: RESULT=id; :};
vacio::=;
tipos::= INTEGER:t {: RESULT="INTEGER"; :} | BOOLEAN:t {: RESULT="BOOLEAN"; :} | ID:id {: RESULT=id.getLexema();:};


// ----------------------------                     
// Definicion de PARAMETROS
// ---------------------------- 
modo::= OUT:t {: RESULT=t; :} | vacio;

// --------------------
// CUERPO programa
// --------------------
cuerpo::= BEGIN listaSentencias:bloque END ID PUNTOYCOMA
{:
    RESULT=bloque;
:};
cuerpo::= BEGIN 
{:
	BloqueSentencias bloque = new BloqueSentencias();

	RESULT=bloque;
:}
END ID PUNTOYCOMA;



// *****************
// *****************
// *****************
lista_argumentos::= ID:idPar COMA lista_argumentos:listaArg 	{:
                               // Añadir IDs a lista objetos Parametro
                                ListaObjetos lista = new ListaObjetos(listaArg);
                                Parametro par = new Parametro(idPar.getLexema(), 0, idPar.getLine(), idPar.getColumn(),null);
				lista.add(par);
	                        RESULT = lista;
                                :}
			        | ID:idPar {:
				// Añadir ID a lista objetos Variables
				ListaObjetos lista = new ListaObjetos();
				Parametro par = new Parametro(idPar.getLexema(), 0, idPar.getLine(), idPar.getColumn(),null);
				lista.add(par);
	                        RESULT = lista;
				:};
decVariable::=ID:idPar DOSPUNTOS{:
				// Añadir ID a lista objetos Variables
				ListaObjetos lista = new ListaObjetos();
				Var var= new Var (idPar.getLexema(), 0, idPar.getLine(), idPar.getColumn());
				lista.add(var);
	                        RESULT = lista;
				:} | ID:idPar COMA decVariable:listaArg 	{:
                               // Añadir IDs a lista objetos Parametro
                                ListaObjetos lista = new ListaObjetos(listaArg);
                               Var var= new Var (idPar.getLexema(), 0, idPar.getLine(), idPar.getColumn());
							lista.add(var);
	                        RESULT = lista;
				
                                :};
				

lista_parametros::= lista_argumentos:listaArg DOSPUNTOS modo tipos:tp {: 
                            ListaObjetos lista = new ListaObjetos(listaArg);
                            for (int i=0;i<lista.size();i++){
                                Parametro p = (Parametro) lista.get(i);
                                p.setTipo(scopeManager.searchType(tp.toString()));
                            }
                            RESULT=listaArg;
                            :}
                            | lista_argumentos:listaArg1 DOSPUNTOS modo tipos:tp PUNTOYCOMA lista_parametros:listaArg2 {:
        			ListaObjetos lista1 = new ListaObjetos(listaArg1);
                        	for (int i=0;i<lista1.size();i++){
				    Parametro p = (Parametro) lista1.get(i);
				    p.setTipo(scopeManager.searchType(tp.toString()));
				}

				ListaObjetos lista2 = new ListaObjetos(listaArg2);
				for (int i=0;i<lista2.size();i++){
						lista1.add(lista2.get(i));
    				}
				RESULT=lista1;	
                            :};

